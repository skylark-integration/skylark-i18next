/**
 * skylark-i18next - A version of i18next.js that ported to running on skylarkjs.
 * @author Hudaokeji, Inc.
 * @version v0.9.0
 * @link https://github.com/skylark-integration/skylark-i18next/
 * @license MIT
 */
define(["./utils","./logger"],function(e,t){"use strict";return class{constructor(e={}){this.logger=t.create("interpolator"),this.options=e,this.format=e.interpolation&&e.interpolation.format||(e=>e),this.init(e)}init(t={}){t.interpolation||(t.interpolation={escapeValue:!0});const i=t.interpolation;this.escape=void 0!==i.escape?i.escape:e.escape,this.escapeValue=void 0===i.escapeValue||i.escapeValue,this.useRawValueToEscape=void 0!==i.useRawValueToEscape&&i.useRawValueToEscape,this.prefix=i.prefix?e.regexEscape(i.prefix):i.prefixEscaped||"{{",this.suffix=i.suffix?e.regexEscape(i.suffix):i.suffixEscaped||"}}",this.formatSeparator=i.formatSeparator?i.formatSeparator:i.formatSeparator||",",this.unescapePrefix=i.unescapeSuffix?"":i.unescapePrefix||"-",this.unescapeSuffix=this.unescapePrefix?"":i.unescapeSuffix||"",this.nestingPrefix=i.nestingPrefix?e.regexEscape(i.nestingPrefix):i.nestingPrefixEscaped||e.regexEscape("$t("),this.nestingSuffix=i.nestingSuffix?e.regexEscape(i.nestingSuffix):i.nestingSuffixEscaped||e.regexEscape(")"),this.nestingOptionsSeparator=i.nestingOptionsSeparator?i.nestingOptionsSeparator:i.nestingOptionsSeparator||",",this.maxReplaces=i.maxReplaces?i.maxReplaces:1e3,this.alwaysFormat=void 0!==i.alwaysFormat&&i.alwaysFormat,this.resetRegExp()}reset(){this.options&&this.init(this.options)}resetRegExp(){const e=`${this.prefix}(.+?)${this.suffix}`;this.regexp=new RegExp(e,"g");const t=`${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`;this.regexpUnescape=new RegExp(t,"g");const i=`${this.nestingPrefix}(.+?)${this.nestingSuffix}`;this.nestingRegexp=new RegExp(i,"g")}interpolate(t,i,s,a){let r,n,o;const p=this.options&&this.options.interpolation&&this.options.interpolation.defaultVariables||{};function f(e){return e.replace(/\$/g,"$$$$")}const l=t=>{if(t.indexOf(this.formatSeparator)<0){const a=e.getPathWithDefaults(i,p,t);return this.alwaysFormat?this.format(a,void 0,s):a}const r=t.split(this.formatSeparator),n=r.shift().trim(),o=r.join(this.formatSeparator).trim();return this.format(e.getPathWithDefaults(i,p,n),o,s,a)};this.resetRegExp();const c=a&&a.missingInterpolationHandler||this.options.missingInterpolationHandler,g=a&&a.interpolation&&a.interpolation.skipOnVariables||this.options.interpolation.skipOnVariables;return[{regex:this.regexpUnescape,safeValue:e=>f(e)},{regex:this.regexp,safeValue:e=>this.escapeValue?f(this.escape(e)):f(e)}].forEach(i=>{for(o=0;r=i.regex.exec(t);){if(void 0===(n=l(r[1].trim())))if("function"==typeof c){const e=c(t,r,a);n="string"==typeof e?e:""}else{if(g){n=r[0];continue}this.logger.warn(`missed to pass in variable ${r[1]} for interpolating ${t}`),n=""}else"string"==typeof n||this.useRawValueToEscape||(n=e.makeString(n));if(t=t.replace(r[0],i.safeValue(n)),i.regex.lastIndex=0,++o>=this.maxReplaces)break}}),t}nest(t,i,s={}){let a,r,n={...s};function o(e,t){const i=this.nestingOptionsSeparator;if(e.indexOf(i)<0)return e;const s=e.split(new RegExp(`${i}[ ]*{`));let a=`{${s[1]}`;e=s[0],a=(a=this.interpolate(a,n)).replace(/'/g,'"');try{n=JSON.parse(a),t&&(n={...t,...n})}catch(t){return this.logger.warn(`failed parsing options string in nesting for key ${e}`,t),`${e}${i}${a}`}return delete n.defaultValue,e}for(n.applyPostProcessor=!1,delete n.defaultValue;a=this.nestingRegexp.exec(t);){let p=[],f=!1;if(a[0].includes(this.formatSeparator)&&!/{.*}/.test(a[1])){const e=a[1].split(this.formatSeparator).map(e=>e.trim());a[1]=e.shift(),p=e,f=!0}if((r=i(o.call(this,a[1].trim(),n),n))&&a[0]===t&&"string"!=typeof r)return r;"string"!=typeof r&&(r=e.makeString(r)),r||(this.logger.warn(`missed to resolve ${a[1]} for nesting ${t}`),r=""),f&&(r=p.reduce((e,t)=>this.format(e,t,s.lng,s),r.trim())),t=t.replace(a[0],r),this.regexp.lastIndex=0}return t}}});
//# sourceMappingURL=sourcemaps/Interpolator.js.map
