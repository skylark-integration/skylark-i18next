/**
 * skylark-i18next - A version of i18next.js that ported to running on skylarkjs.
 * @author Hudaokeji, Inc.
 * @version v0.9.0
 * @link https://github.com/skylark-integration/skylark-i18next/
 * @license MIT
 */
define(["./logger","./EventEmitter","./postProcessor","./utils"],function(t,e,s,o){"use strict";const i={};return class extends e{constructor(s,i={}){super(),o.isIE10&&e.call(this),o.copy(["resourceStore","languageUtils","pluralResolver","interpolator","backendConnector","i18nFormat","utils"],s,this),this.options=i,void 0===this.options.keySeparator&&(this.options.keySeparator="."),this.logger=t.create("translator")}changeLanguage(t){t&&(this.language=t)}exists(t,e={interpolation:{}}){const s=this.resolve(t,e);return s&&void 0!==s.res}extractFromKey(t,e){let s=void 0!==e.nsSeparator?e.nsSeparator:this.options.nsSeparator;void 0===s&&(s=":");const o=void 0!==e.keySeparator?e.keySeparator:this.options.keySeparator;let i=e.ns||this.options.defaultNS;if(s&&t.indexOf(s)>-1){const e=t.match(this.interpolator.nestingRegexp);if(e&&e.length>0)return{key:t,namespaces:i};const n=t.split(s);(s!==o||s===o&&this.options.ns.indexOf(n[0])>-1)&&(i=n.shift()),t=n.join(o)}return"string"==typeof i&&(i=[i]),{key:t,namespaces:i}}translate(t,e,s){if("object"!=typeof e&&this.options.overloadTranslationOptionHandler&&(e=this.options.overloadTranslationOptionHandler(arguments)),e||(e={}),void 0===t||null===t)return"";Array.isArray(t)||(t=[String(t)]);const o=void 0!==e.keySeparator?e.keySeparator:this.options.keySeparator,{key:i,namespaces:n}=this.extractFromKey(t[t.length-1],e),a=n[n.length-1],r=e.lng||this.language,l=e.appendNamespaceToCIMode||this.options.appendNamespaceToCIMode;if(r&&"cimode"===r.toLowerCase()){if(l){const t=e.nsSeparator||this.options.nsSeparator;return a+t+i}return i}const p=this.resolve(t,e);let h=p&&p.res;const c=p&&p.usedKey||i,u=p&&p.exactUsedKey||i,g=Object.prototype.toString.apply(h),d=void 0!==e.joinArrays?e.joinArrays:this.options.joinArrays,f=!this.i18nFormat||this.i18nFormat.handleAsObject;if(f&&h&&"string"!=typeof h&&"boolean"!=typeof h&&"number"!=typeof h&&["[object Number]","[object Function]","[object RegExp]"].indexOf(g)<0&&("string"!=typeof d||"[object Array]"!==g)){if(!e.returnObjects&&!this.options.returnObjects)return this.logger.warn("accessing an object - but returnObjects options is not enabled!"),this.options.returnedObjectHandler?this.options.returnedObjectHandler(c,h,e):`key '${i} (${this.language})' returned an object instead of string.`;if(o){const t="[object Array]"===g,s=t?[]:{};let i=t?u:c;for(const t in h)if(Object.prototype.hasOwnProperty.call(h,t)){const a=`${i}${o}${t}`;s[t]=this.translate(a,{...e,...{joinArrays:!1,ns:n}}),s[t]===a&&(s[t]=h[t])}h=s}}else if(f&&"string"==typeof d&&"[object Array]"===g)(h=h.join(d))&&(h=this.extendTranslation(h,t,e,s));else{let n=!1,l=!1;if(!this.isValidLookup(h)&&void 0!==e.defaultValue){if(n=!0,void 0!==e.count){const t=this.pluralResolver.getSuffix(r,e.count);h=e[`defaultValue${t}`]}h||(h=e.defaultValue)}this.isValidLookup(h)||(l=!0,h=i);const c=e.defaultValue&&e.defaultValue!==h&&this.options.updateMissing;if(l||n||c){if(this.logger.log(c?"updateKey":"missingKey",r,a,i,c?e.defaultValue:h),o){const t=this.resolve(i,{...e,keySeparator:!1});t&&t.res&&this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.")}let t=[];const s=this.languageUtils.getFallbackCodes(this.options.fallbackLng,e.lng||this.language);if("fallback"===this.options.saveMissingTo&&s&&s[0])for(let e=0;e<s.length;e++)t.push(s[e]);else"all"===this.options.saveMissingTo?t=this.languageUtils.toResolveHierarchy(e.lng||this.language):t.push(e.lng||this.language);const n=(t,s)=>{this.options.missingKeyHandler?this.options.missingKeyHandler(t,a,s,c?e.defaultValue:h,c,e):this.backendConnector&&this.backendConnector.saveMissing&&this.backendConnector.saveMissing(t,a,s,c?e.defaultValue:h,c,e),this.emit("missingKey",t,a,s,h)};if(this.options.saveMissing){const s=void 0!==e.count&&"string"!=typeof e.count;this.options.saveMissingPlurals&&s?t.forEach(t=>{this.pluralResolver.getPluralFormsOfKey(t,i).forEach(e=>n([t],e))}):n(t,i)}}h=this.extendTranslation(h,t,e,p,s),l&&h===i&&this.options.appendNamespaceToMissingKey&&(h=`${a}:${i}`),l&&this.options.parseMissingKeyHandler&&(h=this.options.parseMissingKeyHandler(h))}return h}extendTranslation(t,e,o,i,n){if(this.i18nFormat&&this.i18nFormat.parse)t=this.i18nFormat.parse(t,o,i.usedLng,i.usedNS,i.usedKey,{resolved:i});else if(!o.skipInterpolation){o.interpolation&&this.interpolator.init({...o,...{interpolation:{...this.options.interpolation,...o.interpolation}}});const s=o.interpolation&&o.interpolation.skipOnVariables||this.options.interpolation.skipOnVariables;let i;if(s){const e=t.match(this.interpolator.nestingRegexp);i=e&&e.length}let a=o.replace&&"string"!=typeof o.replace?o.replace:o;if(this.options.interpolation.defaultVariables&&(a={...this.options.interpolation.defaultVariables,...a}),t=this.interpolator.interpolate(t,a,o.lng||this.language,o),s){const e=t.match(this.interpolator.nestingRegexp);i<(e&&e.length)&&(o.nest=!1)}!1!==o.nest&&(t=this.interpolator.nest(t,(...t)=>n&&n[0]===t[0]?(this.logger.warn(`It seems you are nesting recursively key: ${t[0]} in key: ${e[0]}`),null):this.translate(...t,e),o)),o.interpolation&&this.interpolator.reset()}const a=o.postProcess||this.options.postProcess,r="string"==typeof a?[a]:a;return void 0!==t&&null!==t&&r&&r.length&&!1!==o.applyPostProcessor&&(t=s.handle(r,t,e,this.options&&this.options.postProcessPassResolved?{i18nResolved:i,...o}:o,this)),t}resolve(t,e={}){let s,o,n,a,r;return"string"==typeof t&&(t=[t]),t.forEach(t=>{if(this.isValidLookup(s))return;const l=this.extractFromKey(t,e),p=l.key;o=p;let h=l.namespaces;this.options.fallbackNS&&(h=h.concat(this.options.fallbackNS));const c=void 0!==e.count&&"string"!=typeof e.count,u=void 0!==e.context&&"string"==typeof e.context&&""!==e.context,g=e.lngs?e.lngs:this.languageUtils.toResolveHierarchy(e.lng||this.language,e.fallbackLng);h.forEach(t=>{this.isValidLookup(s)||(r=t,!i[`${g[0]}-${t}`]&&this.utils&&this.utils.hasLoadedNamespace&&!this.utils.hasLoadedNamespace(r)&&(i[`${g[0]}-${t}`]=!0,this.logger.warn(`key "${o}" for languages "${g.join(", ")}" won't get resolved as namespace "${r}" was not yet loaded`,"This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")),g.forEach(o=>{if(this.isValidLookup(s))return;a=o;let i=p;const r=[i];if(this.i18nFormat&&this.i18nFormat.addLookupKeys)this.i18nFormat.addLookupKeys(r,p,o,t,e);else{let t;c&&(t=this.pluralResolver.getSuffix(o,e.count)),c&&u&&r.push(i+t),u&&r.push(i+=`${this.options.contextSeparator}${e.context}`),c&&r.push(i+=t)}let l;for(;l=r.pop();)this.isValidLookup(s)||(n=l,s=this.getResource(o,t,l,e))}))})}),{res:s,usedKey:o,exactUsedKey:n,usedLng:a,usedNS:r}}isValidLookup(t){return!(void 0===t||!this.options.returnNull&&null===t||!this.options.returnEmptyString&&""===t)}getResource(t,e,s,o={}){return this.i18nFormat&&this.i18nFormat.getResource?this.i18nFormat.getResource(t,e,s,o):this.resourceStore.getResource(t,e,s,o)}}});
//# sourceMappingURL=sourcemaps/Translator.js.map
