{"version":3,"sources":["Interpolator.js"],"names":["define","utils","baseLogger","[object Object]","options","this","logger","create","format","interpolation","value","init","escapeValue","iOpts","escape","undefined","useRawValueToEscape","prefix","regexEscape","prefixEscaped","suffix","suffixEscaped","formatSeparator","unescapePrefix","unescapeSuffix","nestingPrefix","nestingPrefixEscaped","nestingSuffix","nestingSuffixEscaped","nestingOptionsSeparator","maxReplaces","alwaysFormat","resetRegExp","regexpStr","regexp","RegExp","regexpUnescapeStr","regexpUnescape","nestingRegexpStr","nestingRegexp","str","data","lng","match","replaces","defaultData","defaultVariables","regexSafe","val","replace","handleFormat","key","indexOf","path","getPathWithDefaults","p","split","k","shift","trim","f","join","missingInterpolationHandler","skipOnVariables","regex","safeValue","forEach","todo","exec","temp","warn","makeString","lastIndex","fc","clonedOptions","handleHasOptions","inheritedOptions","sep","c","optionsString","interpolate","JSON","parse","e","defaultValue","applyPostProcessor","formatters","doReduce","includes","test","r","map","elem","call","reduce","v"],"mappings":"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","file":"../Interpolator.js","sourcesContent":["define([\n    './utils',\n    './logger'\n], function (utils, baseLogger) {\n    'use strict';\n    class Interpolator {\n        constructor(options = {}) {\n            this.logger = baseLogger.create('interpolator');\n            this.options = options;\n            this.format = options.interpolation && options.interpolation.format || (value => value);\n            this.init(options);\n        }\n        init(options = {}) {\n            if (!options.interpolation)\n                options.interpolation = { escapeValue: true };\n            const iOpts = options.interpolation;\n            this.escape = iOpts.escape !== undefined ? iOpts.escape : utils.escape;\n            this.escapeValue = iOpts.escapeValue !== undefined ? iOpts.escapeValue : true;\n            this.useRawValueToEscape = iOpts.useRawValueToEscape !== undefined ? iOpts.useRawValueToEscape : false;\n            this.prefix = iOpts.prefix ? utils.regexEscape(iOpts.prefix) : iOpts.prefixEscaped || '{{';\n            this.suffix = iOpts.suffix ? utils.regexEscape(iOpts.suffix) : iOpts.suffixEscaped || '}}';\n            this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ',';\n            this.unescapePrefix = iOpts.unescapeSuffix ? '' : iOpts.unescapePrefix || '-';\n            this.unescapeSuffix = this.unescapePrefix ? '' : iOpts.unescapeSuffix || '';\n            this.nestingPrefix = iOpts.nestingPrefix ? utils.regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || utils.regexEscape('$t(');\n            this.nestingSuffix = iOpts.nestingSuffix ? utils.regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || utils.regexEscape(')');\n            this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || ',';\n            this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1000;\n            this.alwaysFormat = iOpts.alwaysFormat !== undefined ? iOpts.alwaysFormat : false;\n            this.resetRegExp();\n        }\n        reset() {\n            if (this.options)\n                this.init(this.options);\n        }\n        resetRegExp() {\n            const regexpStr = `${ this.prefix }(.+?)${ this.suffix }`;\n            this.regexp = new RegExp(regexpStr, 'g');\n            const regexpUnescapeStr = `${ this.prefix }${ this.unescapePrefix }(.+?)${ this.unescapeSuffix }${ this.suffix }`;\n            this.regexpUnescape = new RegExp(regexpUnescapeStr, 'g');\n            const nestingRegexpStr = `${ this.nestingPrefix }(.+?)${ this.nestingSuffix }`;\n            this.nestingRegexp = new RegExp(nestingRegexpStr, 'g');\n        }\n        interpolate(str, data, lng, options) {\n            let match;\n            let value;\n            let replaces;\n            const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};\n            function regexSafe(val) {\n                return val.replace(/\\$/g, '$$$$');\n            }\n            const handleFormat = key => {\n                if (key.indexOf(this.formatSeparator) < 0) {\n                    const path = utils.getPathWithDefaults(data, defaultData, key);\n                    return this.alwaysFormat ? this.format(path, undefined, lng) : path;\n                }\n                const p = key.split(this.formatSeparator);\n                const k = p.shift().trim();\n                const f = p.join(this.formatSeparator).trim();\n                return this.format(utils.getPathWithDefaults(data, defaultData, k), f, lng, options);\n            };\n            this.resetRegExp();\n            const missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;\n            const skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables || this.options.interpolation.skipOnVariables;\n            const todos = [\n                {\n                    regex: this.regexpUnescape,\n                    safeValue: val => regexSafe(val)\n                },\n                {\n                    regex: this.regexp,\n                    safeValue: val => this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val)\n                }\n            ];\n            todos.forEach(todo => {\n                replaces = 0;\n                while (match = todo.regex.exec(str)) {\n                    value = handleFormat(match[1].trim());\n                    if (value === undefined) {\n                        if (typeof missingInterpolationHandler === 'function') {\n                            const temp = missingInterpolationHandler(str, match, options);\n                            value = typeof temp === 'string' ? temp : '';\n                        } else if (skipOnVariables) {\n                            value = match[0];\n                            continue;\n                        } else {\n                            this.logger.warn(`missed to pass in variable ${ match[1] } for interpolating ${ str }`);\n                            value = '';\n                        }\n                    } else if (typeof value !== 'string' && !this.useRawValueToEscape) {\n                        value = utils.makeString(value);\n                    }\n                    str = str.replace(match[0], todo.safeValue(value));\n                    todo.regex.lastIndex = 0;\n                    replaces++;\n                    if (replaces >= this.maxReplaces) {\n                        break;\n                    }\n                }\n            });\n            return str;\n        }\n        nest(str, fc, options = {}) {\n            let match;\n            let value;\n            let clonedOptions = { ...options };\n            clonedOptions.applyPostProcessor = false;\n            delete clonedOptions.defaultValue;\n            function handleHasOptions(key, inheritedOptions) {\n                const sep = this.nestingOptionsSeparator;\n                if (key.indexOf(sep) < 0)\n                    return key;\n                const c = key.split(new RegExp(`${ sep }[ ]*{`));\n                let optionsString = `{${ c[1] }`;\n                key = c[0];\n                optionsString = this.interpolate(optionsString, clonedOptions);\n                optionsString = optionsString.replace(/'/g, '\"');\n                try {\n                    clonedOptions = JSON.parse(optionsString);\n                    if (inheritedOptions)\n                        clonedOptions = {\n                            ...inheritedOptions,\n                            ...clonedOptions\n                        };\n                } catch (e) {\n                    this.logger.warn(`failed parsing options string in nesting for key ${ key }`, e);\n                    return `${ key }${ sep }${ optionsString }`;\n                }\n                delete clonedOptions.defaultValue;\n                return key;\n            }\n            while (match = this.nestingRegexp.exec(str)) {\n                let formatters = [];\n                let doReduce = false;\n                if (match[0].includes(this.formatSeparator) && !/{.*}/.test(match[1])) {\n                    const r = match[1].split(this.formatSeparator).map(elem => elem.trim());\n                    match[1] = r.shift();\n                    formatters = r;\n                    doReduce = true;\n                }\n                value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);\n                if (value && match[0] === str && typeof value !== 'string')\n                    return value;\n                if (typeof value !== 'string')\n                    value = utils.makeString(value);\n                if (!value) {\n                    this.logger.warn(`missed to resolve ${ match[1] } for nesting ${ str }`);\n                    value = '';\n                }\n                if (doReduce) {\n                    value = formatters.reduce((v, f) => this.format(v, f, options.lng, options), value.trim());\n                }\n                str = str.replace(match[0], value);\n                this.regexp.lastIndex = 0;\n            }\n            return str;\n        }\n    }\n    return Interpolator;\n});"]}