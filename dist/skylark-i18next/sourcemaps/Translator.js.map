{"version":3,"sources":["Translator.js"],"names":["define","baseLogger","EventEmitter","postProcessor","utils","checkedLoadedFor","[object Object]","services","options","super","isIE10","call","this","copy","undefined","keySeparator","logger","create","lng","language","key","interpolation","resolved","resolve","res","nsSeparator","namespaces","ns","defaultNS","indexOf","m","match","interpolator","nestingRegexp","length","parts","split","shift","join","keys","lastKey","overloadTranslationOptionHandler","arguments","Array","isArray","String","extractFromKey","namespace","appendNamespaceToCIMode","toLowerCase","resUsedKey","usedKey","resExactUsedKey","exactUsedKey","resType","Object","prototype","toString","apply","joinArrays","handleAsObjectInI18nFormat","i18nFormat","handleAsObject","returnObjects","warn","returnedObjectHandler","resTypeIsArray","newKeyToUse","hasOwnProperty","deepKey","translate","extendTranslation","usedDefault","isValidLookup","defaultValue","count","suffix","pluralResolver","getSuffix","updateMissing","log","fk","lngs","fallbackLngs","languageUtils","getFallbackCodes","fallbackLng","saveMissingTo","i","push","toResolveHierarchy","send","l","k","missingKeyHandler","backendConnector","saveMissing","emit","needsPluralHandling","saveMissingPlurals","forEach","getPluralFormsOfKey","p","appendNamespaceToMissingKey","parseMissingKeyHandler","parse","usedLng","usedNS","skipInterpolation","init","skipOnVariables","nestBef","nb","data","replace","defaultVariables","interpolate","na","nest","args","reset","postProcess","postProcessorNames","applyPostProcessor","handle","postProcessPassResolved","i18nResolved","found","extracted","fallbackNS","concat","needsContextHandling","context","codes","hasLoadedNamespace","code","finalKey","finalKeys","addLookupKeys","pluralSuffix","contextSeparator","possibleKey","pop","getResource","returnNull","returnEmptyString","resourceStore"],"mappings":"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","file":"../Translator.js","sourcesContent":["define([\n    './logger',\n    './EventEmitter',\n    './postProcessor',\n    './utils'\n], function (baseLogger, EventEmitter, postProcessor, utils) {\n    'use strict';\n    const checkedLoadedFor = {};\n    class Translator extends EventEmitter {\n        constructor(services, options = {}) {\n            super();\n            if (utils.isIE10) {\n                EventEmitter.call(this);\n            }\n            utils.copy([\n                'resourceStore',\n                'languageUtils',\n                'pluralResolver',\n                'interpolator',\n                'backendConnector',\n                'i18nFormat',\n                'utils'\n            ], services, this);\n            this.options = options;\n            if (this.options.keySeparator === undefined) {\n                this.options.keySeparator = '.';\n            }\n            this.logger = baseLogger.create('translator');\n        }\n        changeLanguage(lng) {\n            if (lng)\n                this.language = lng;\n        }\n        exists(key, options = { interpolation: {} }) {\n            const resolved = this.resolve(key, options);\n            return resolved && resolved.res !== undefined;\n        }\n        extractFromKey(key, options) {\n            let nsSeparator = options.nsSeparator !== undefined ? options.nsSeparator : this.options.nsSeparator;\n            if (nsSeparator === undefined)\n                nsSeparator = ':';\n            const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n            let namespaces = options.ns || this.options.defaultNS;\n            if (nsSeparator && key.indexOf(nsSeparator) > -1) {\n                const m = key.match(this.interpolator.nestingRegexp);\n                if (m && m.length > 0) {\n                    return {\n                        key,\n                        namespaces\n                    };\n                }\n                const parts = key.split(nsSeparator);\n                if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1)\n                    namespaces = parts.shift();\n                key = parts.join(keySeparator);\n            }\n            if (typeof namespaces === 'string')\n                namespaces = [namespaces];\n            return {\n                key,\n                namespaces\n            };\n        }\n        translate(keys, options, lastKey) {\n            if (typeof options !== 'object' && this.options.overloadTranslationOptionHandler) {\n                options = this.options.overloadTranslationOptionHandler(arguments);\n            }\n            if (!options)\n                options = {};\n            if (keys === undefined || keys === null)\n                return '';\n            if (!Array.isArray(keys))\n                keys = [String(keys)];\n            const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n            const {key, namespaces} = this.extractFromKey(keys[keys.length - 1], options);\n            const namespace = namespaces[namespaces.length - 1];\n            const lng = options.lng || this.language;\n            const appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;\n            if (lng && lng.toLowerCase() === 'cimode') {\n                if (appendNamespaceToCIMode) {\n                    const nsSeparator = options.nsSeparator || this.options.nsSeparator;\n                    return namespace + nsSeparator + key;\n                }\n                return key;\n            }\n            const resolved = this.resolve(keys, options);\n            let res = resolved && resolved.res;\n            const resUsedKey = resolved && resolved.usedKey || key;\n            const resExactUsedKey = resolved && resolved.exactUsedKey || key;\n            const resType = Object.prototype.toString.apply(res);\n            const noObject = [\n                '[object Number]',\n                '[object Function]',\n                '[object RegExp]'\n            ];\n            const joinArrays = options.joinArrays !== undefined ? options.joinArrays : this.options.joinArrays;\n            const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;\n            const handleAsObject = typeof res !== 'string' && typeof res !== 'boolean' && typeof res !== 'number';\n            if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === 'string' && resType === '[object Array]')) {\n                if (!options.returnObjects && !this.options.returnObjects) {\n                    this.logger.warn('accessing an object - but returnObjects options is not enabled!');\n                    return this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, options) : `key '${ key } (${ this.language })' returned an object instead of string.`;\n                }\n                if (keySeparator) {\n                    const resTypeIsArray = resType === '[object Array]';\n                    const copy = resTypeIsArray ? [] : {};\n                    let newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;\n                    for (const m in res) {\n                        if (Object.prototype.hasOwnProperty.call(res, m)) {\n                            const deepKey = `${ newKeyToUse }${ keySeparator }${ m }`;\n                            copy[m] = this.translate(deepKey, {\n                                ...options,\n                                ...{\n                                    joinArrays: false,\n                                    ns: namespaces\n                                }\n                            });\n                            if (copy[m] === deepKey)\n                                copy[m] = res[m];\n                        }\n                    }\n                    res = copy;\n                }\n            } else if (handleAsObjectInI18nFormat && typeof joinArrays === 'string' && resType === '[object Array]') {\n                res = res.join(joinArrays);\n                if (res)\n                    res = this.extendTranslation(res, keys, options, lastKey);\n            } else {\n                let usedDefault = false;\n                let usedKey = false;\n                if (!this.isValidLookup(res) && options.defaultValue !== undefined) {\n                    usedDefault = true;\n                    if (options.count !== undefined) {\n                        const suffix = this.pluralResolver.getSuffix(lng, options.count);\n                        res = options[`defaultValue${ suffix }`];\n                    }\n                    if (!res)\n                        res = options.defaultValue;\n                }\n                if (!this.isValidLookup(res)) {\n                    usedKey = true;\n                    res = key;\n                }\n                const updateMissing = options.defaultValue && options.defaultValue !== res && this.options.updateMissing;\n                if (usedKey || usedDefault || updateMissing) {\n                    this.logger.log(updateMissing ? 'updateKey' : 'missingKey', lng, namespace, key, updateMissing ? options.defaultValue : res);\n                    if (keySeparator) {\n                        const fk = this.resolve(key, {\n                            ...options,\n                            keySeparator: false\n                        });\n                        if (fk && fk.res)\n                            this.logger.warn('Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.');\n                    }\n                    let lngs = [];\n                    const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);\n                    if (this.options.saveMissingTo === 'fallback' && fallbackLngs && fallbackLngs[0]) {\n                        for (let i = 0; i < fallbackLngs.length; i++) {\n                            lngs.push(fallbackLngs[i]);\n                        }\n                    } else if (this.options.saveMissingTo === 'all') {\n                        lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);\n                    } else {\n                        lngs.push(options.lng || this.language);\n                    }\n                    const send = (l, k) => {\n                        if (this.options.missingKeyHandler) {\n                            this.options.missingKeyHandler(l, namespace, k, updateMissing ? options.defaultValue : res, updateMissing, options);\n                        } else if (this.backendConnector && this.backendConnector.saveMissing) {\n                            this.backendConnector.saveMissing(l, namespace, k, updateMissing ? options.defaultValue : res, updateMissing, options);\n                        }\n                        this.emit('missingKey', l, namespace, k, res);\n                    };\n                    if (this.options.saveMissing) {\n                        const needsPluralHandling = options.count !== undefined && typeof options.count !== 'string';\n                        if (this.options.saveMissingPlurals && needsPluralHandling) {\n                            lngs.forEach(l => {\n                                const plurals = this.pluralResolver.getPluralFormsOfKey(l, key);\n                                plurals.forEach(p => send([l], p));\n                            });\n                        } else {\n                            send(lngs, key);\n                        }\n                    }\n                }\n                res = this.extendTranslation(res, keys, options, resolved, lastKey);\n                if (usedKey && res === key && this.options.appendNamespaceToMissingKey)\n                    res = `${ namespace }:${ key }`;\n                if (usedKey && this.options.parseMissingKeyHandler)\n                    res = this.options.parseMissingKeyHandler(res);\n            }\n            return res;\n        }\n        extendTranslation(res, key, options, resolved, lastKey) {\n            if (this.i18nFormat && this.i18nFormat.parse) {\n                res = this.i18nFormat.parse(res, options, resolved.usedLng, resolved.usedNS, resolved.usedKey, { resolved });\n            } else if (!options.skipInterpolation) {\n                if (options.interpolation)\n                    this.interpolator.init({\n                        ...options,\n                        ...{\n                            interpolation: {\n                                ...this.options.interpolation,\n                                ...options.interpolation\n                            }\n                        }\n                    });\n                const skipOnVariables = options.interpolation && options.interpolation.skipOnVariables || this.options.interpolation.skipOnVariables;\n                let nestBef;\n                if (skipOnVariables) {\n                    const nb = res.match(this.interpolator.nestingRegexp);\n                    nestBef = nb && nb.length;\n                }\n                let data = options.replace && typeof options.replace !== 'string' ? options.replace : options;\n                if (this.options.interpolation.defaultVariables)\n                    data = {\n                        ...this.options.interpolation.defaultVariables,\n                        ...data\n                    };\n                res = this.interpolator.interpolate(res, data, options.lng || this.language, options);\n                if (skipOnVariables) {\n                    const na = res.match(this.interpolator.nestingRegexp);\n                    const nestAft = na && na.length;\n                    if (nestBef < nestAft)\n                        options.nest = false;\n                }\n                if (options.nest !== false)\n                    res = this.interpolator.nest(res, (...args) => {\n                        if (lastKey && lastKey[0] === args[0]) {\n                            this.logger.warn(`It seems you are nesting recursively key: ${ args[0] } in key: ${ key[0] }`);\n                            return null;\n                        }\n                        return this.translate(...args, key);\n                    }, options);\n                if (options.interpolation)\n                    this.interpolator.reset();\n            }\n            const postProcess = options.postProcess || this.options.postProcess;\n            const postProcessorNames = typeof postProcess === 'string' ? [postProcess] : postProcess;\n            if (res !== undefined && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {\n                res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? {\n                    i18nResolved: resolved,\n                    ...options\n                } : options, this);\n            }\n            return res;\n        }\n        resolve(keys, options = {}) {\n            let found;\n            let usedKey;\n            let exactUsedKey;\n            let usedLng;\n            let usedNS;\n            if (typeof keys === 'string')\n                keys = [keys];\n            keys.forEach(k => {\n                if (this.isValidLookup(found))\n                    return;\n                const extracted = this.extractFromKey(k, options);\n                const key = extracted.key;\n                usedKey = key;\n                let namespaces = extracted.namespaces;\n                if (this.options.fallbackNS)\n                    namespaces = namespaces.concat(this.options.fallbackNS);\n                const needsPluralHandling = options.count !== undefined && typeof options.count !== 'string';\n                const needsContextHandling = options.context !== undefined && typeof options.context === 'string' && options.context !== '';\n                const codes = options.lngs ? options.lngs : this.languageUtils.toResolveHierarchy(options.lng || this.language, options.fallbackLng);\n                namespaces.forEach(ns => {\n                    if (this.isValidLookup(found))\n                        return;\n                    usedNS = ns;\n                    if (!checkedLoadedFor[`${ codes[0] }-${ ns }`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(usedNS)) {\n                        checkedLoadedFor[`${ codes[0] }-${ ns }`] = true;\n                        this.logger.warn(`key \"${ usedKey }\" for languages \"${ codes.join(', ') }\" won't get resolved as namespace \"${ usedNS }\" was not yet loaded`, 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');\n                    }\n                    codes.forEach(code => {\n                        if (this.isValidLookup(found))\n                            return;\n                        usedLng = code;\n                        let finalKey = key;\n                        const finalKeys = [finalKey];\n                        if (this.i18nFormat && this.i18nFormat.addLookupKeys) {\n                            this.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);\n                        } else {\n                            let pluralSuffix;\n                            if (needsPluralHandling)\n                                pluralSuffix = this.pluralResolver.getSuffix(code, options.count);\n                            if (needsPluralHandling && needsContextHandling)\n                                finalKeys.push(finalKey + pluralSuffix);\n                            if (needsContextHandling)\n                                finalKeys.push(finalKey += `${ this.options.contextSeparator }${ options.context }`);\n                            if (needsPluralHandling)\n                                finalKeys.push(finalKey += pluralSuffix);\n                        }\n                        let possibleKey;\n                        while (possibleKey = finalKeys.pop()) {\n                            if (!this.isValidLookup(found)) {\n                                exactUsedKey = possibleKey;\n                                found = this.getResource(code, ns, possibleKey, options);\n                            }\n                        }\n                    });\n                });\n            });\n            return {\n                res: found,\n                usedKey,\n                exactUsedKey,\n                usedLng,\n                usedNS\n            };\n        }\n        isValidLookup(res) {\n            return res !== undefined && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === '');\n        }\n        getResource(code, ns, key, options = {}) {\n            if (this.i18nFormat && this.i18nFormat.getResource)\n                return this.i18nFormat.getResource(code, ns, key, options);\n            return this.resourceStore.getResource(code, ns, key, options);\n        }\n    }\n    return Translator;\n});"]}