{"version":3,"sources":["skylark-i18next.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../skylark-i18next.js","sourcesContent":["define('skylark-i18next/logger',[],function () {\n    'use strict';\n    const consoleLogger = {\n        type: 'logger',\n        log(args) {\n            this.output('log', args);\n        },\n        warn(args) {\n            this.output('warn', args);\n        },\n        error(args) {\n            this.output('error', args);\n        },\n        output(type, args) {\n            if (console && console[type])\n                console[type].apply(console, args);\n        }\n    };\n    class Logger {\n        constructor(concreteLogger, options = {}) {\n            this.init(concreteLogger, options);\n        }\n        init(concreteLogger, options = {}) {\n            this.prefix = options.prefix || 'i18next:';\n            this.logger = concreteLogger || consoleLogger;\n            this.options = options;\n            this.debug = options.debug;\n        }\n        setDebug(bool) {\n            this.debug = bool;\n        }\n        log(...args) {\n            return this.forward(args, 'log', '', true);\n        }\n        warn(...args) {\n            return this.forward(args, 'warn', '', true);\n        }\n        error(...args) {\n            return this.forward(args, 'error', '');\n        }\n        deprecate(...args) {\n            return this.forward(args, 'warn', 'WARNING DEPRECATED: ', true);\n        }\n        forward(args, lvl, prefix, debugOnly) {\n            if (debugOnly && !this.debug)\n                return null;\n            if (typeof args[0] === 'string')\n                args[0] = `${ prefix }${ this.prefix } ${ args[0] }`;\n            return this.logger[lvl](args);\n        }\n        create(moduleName) {\n            return new Logger(this.logger, {\n                ...{ prefix: `${ this.prefix }:${ moduleName }:` },\n                ...this.options\n            });\n        }\n    }\n    return new Logger();\n});\ndefine('skylark-i18next/EventEmitter',[],function () {\n    'use strict';\n    class EventEmitter {\n        constructor() {\n            this.observers = {};\n        }\n        on(events, listener) {\n            events.split(' ').forEach(event => {\n                this.observers[event] = this.observers[event] || [];\n                this.observers[event].push(listener);\n            });\n            return this;\n        }\n        off(event, listener) {\n            if (!this.observers[event])\n                return;\n            if (!listener) {\n                delete this.observers[event];\n                return;\n            }\n            this.observers[event] = this.observers[event].filter(l => l !== listener);\n        }\n        emit(event, ...args) {\n            if (this.observers[event]) {\n                const cloned = [].concat(this.observers[event]);\n                cloned.forEach(observer => {\n                    observer(...args);\n                });\n            }\n            if (this.observers['*']) {\n                const cloned = [].concat(this.observers['*']);\n                cloned.forEach(observer => {\n                    observer.apply(observer, [\n                        event,\n                        ...args\n                    ]);\n                });\n            }\n        }\n    }\n    return EventEmitter;\n});\ndefine('skylark-i18next/utils',[],function () {\n    'use strict';\n    function defer() {\n        let res;\n        let rej;\n        const promise = new Promise((resolve, reject) => {\n            res = resolve;\n            rej = reject;\n        });\n        promise.resolve = res;\n        promise.reject = rej;\n        return promise;\n    }\n    function makeString(object) {\n        if (object == null)\n            return '';\n        return '' + object;\n    }\n    function copy(a, s, t) {\n        a.forEach(m => {\n            if (s[m])\n                t[m] = s[m];\n        });\n    }\n    function getLastOfPath(object, path, Empty) {\n        function cleanKey(key) {\n            return key && key.indexOf('###') > -1 ? key.replace(/###/g, '.') : key;\n        }\n        function canNotTraverseDeeper() {\n            return !object || typeof object === 'string';\n        }\n        const stack = typeof path !== 'string' ? [].concat(path) : path.split('.');\n        while (stack.length > 1) {\n            if (canNotTraverseDeeper())\n                return {};\n            const key = cleanKey(stack.shift());\n            if (!object[key] && Empty)\n                object[key] = new Empty();\n            object = object[key];\n        }\n        if (canNotTraverseDeeper())\n            return {};\n        return {\n            obj: object,\n            k: cleanKey(stack.shift())\n        };\n    }\n    function setPath(object, path, newValue) {\n        const {obj, k} = getLastOfPath(object, path, Object);\n        obj[k] = newValue;\n    }\n    function pushPath(object, path, newValue, concat) {\n        const {obj, k} = getLastOfPath(object, path, Object);\n        obj[k] = obj[k] || [];\n        if (concat)\n            obj[k] = obj[k].concat(newValue);\n        if (!concat)\n            obj[k].push(newValue);\n    }\n    function getPath(object, path) {\n        const {obj, k} = getLastOfPath(object, path);\n        if (!obj)\n            return undefined;\n        return obj[k];\n    }\n    function getPathWithDefaults(data, defaultData, key) {\n        const value = getPath(data, key);\n        if (value !== undefined) {\n            return value;\n        }\n        return getPath(defaultData, key);\n    }\n    function deepExtend(target, source, overwrite) {\n        for (const prop in source) {\n            if (prop !== '__proto__') {\n                if (prop in target) {\n                    if (typeof target[prop] === 'string' || target[prop] instanceof String || typeof source[prop] === 'string' || source[prop] instanceof String) {\n                        if (overwrite)\n                            target[prop] = source[prop];\n                    } else {\n                        deepExtend(target[prop], source[prop], overwrite);\n                    }\n                } else {\n                    target[prop] = source[prop];\n                }\n            }\n        }\n        return target;\n    }\n    function regexEscape(str) {\n        return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\n    }\n    var _entityMap = {\n        '&': '&amp;',\n        '<': '&lt;',\n        '>': '&gt;',\n        '\"': '&quot;',\n        \"'\": '&#39;',\n        '/': '&#x2F;'\n    };\n    function escape(data) {\n        if (typeof data === 'string') {\n            return data.replace(/[&<>\"'\\/]/g, s => _entityMap[s]);\n        }\n        return data;\n    }\n    const isIE10 = typeof window !== 'undefined' && window.navigator && window.navigator.userAgent && window.navigator.userAgent.indexOf('MSIE') > -1;\n    return {\n        defer: defer,\n        makeString: makeString,\n        copy: copy,\n        setPath: setPath,\n        pushPath: pushPath,\n        getPath: getPath,\n        getPathWithDefaults: getPathWithDefaults,\n        deepExtend: deepExtend,\n        regexEscape: regexEscape,\n        escape: escape,\n        isIE10: isIE10\n    };\n});\ndefine('skylark-i18next/ResourceStore',[\n    './EventEmitter',\n    './utils'\n], function (EventEmitter, utils) {\n    'use strict';\n    class ResourceStore extends EventEmitter {\n        constructor(data, options = {\n            ns: ['translation'],\n            defaultNS: 'translation'\n        }) {\n            super();\n            if (utils.isIE10) {\n                EventEmitter.call(this);\n            }\n            this.data = data || {};\n            this.options = options;\n            if (this.options.keySeparator === undefined) {\n                this.options.keySeparator = '.';\n            }\n        }\n        addNamespaces(ns) {\n            if (this.options.ns.indexOf(ns) < 0) {\n                this.options.ns.push(ns);\n            }\n        }\n        removeNamespaces(ns) {\n            const index = this.options.ns.indexOf(ns);\n            if (index > -1) {\n                this.options.ns.splice(index, 1);\n            }\n        }\n        getResource(lng, ns, key, options = {}) {\n            const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n            let path = [\n                lng,\n                ns\n            ];\n            if (key && typeof key !== 'string')\n                path = path.concat(key);\n            if (key && typeof key === 'string')\n                path = path.concat(keySeparator ? key.split(keySeparator) : key);\n            if (lng.indexOf('.') > -1) {\n                path = lng.split('.');\n            }\n            return utils.getPath(this.data, path);\n        }\n        addResource(lng, ns, key, value, options = { silent: false }) {\n            let keySeparator = this.options.keySeparator;\n            if (keySeparator === undefined)\n                keySeparator = '.';\n            let path = [\n                lng,\n                ns\n            ];\n            if (key)\n                path = path.concat(keySeparator ? key.split(keySeparator) : key);\n            if (lng.indexOf('.') > -1) {\n                path = lng.split('.');\n                value = ns;\n                ns = path[1];\n            }\n            this.addNamespaces(ns);\n            utils.setPath(this.data, path, value);\n            if (!options.silent)\n                this.emit('added', lng, ns, key, value);\n        }\n        addResources(lng, ns, resources, options = { silent: false }) {\n            for (const m in resources) {\n                if (typeof resources[m] === 'string' || Object.prototype.toString.apply(resources[m]) === '[object Array]')\n                    this.addResource(lng, ns, m, resources[m], { silent: true });\n            }\n            if (!options.silent)\n                this.emit('added', lng, ns, resources);\n        }\n        addResourceBundle(lng, ns, resources, deep, overwrite, options = { silent: false }) {\n            let path = [\n                lng,\n                ns\n            ];\n            if (lng.indexOf('.') > -1) {\n                path = lng.split('.');\n                deep = resources;\n                resources = ns;\n                ns = path[1];\n            }\n            this.addNamespaces(ns);\n            let pack = utils.getPath(this.data, path) || {};\n            if (deep) {\n                utils.deepExtend(pack, resources, overwrite);\n            } else {\n                pack = {\n                    ...pack,\n                    ...resources\n                };\n            }\n            utils.setPath(this.data, path, pack);\n            if (!options.silent)\n                this.emit('added', lng, ns, resources);\n        }\n        removeResourceBundle(lng, ns) {\n            if (this.hasResourceBundle(lng, ns)) {\n                delete this.data[lng][ns];\n            }\n            this.removeNamespaces(ns);\n            this.emit('removed', lng, ns);\n        }\n        hasResourceBundle(lng, ns) {\n            return this.getResource(lng, ns) !== undefined;\n        }\n        getResourceBundle(lng, ns) {\n            if (!ns)\n                ns = this.options.defaultNS;\n            if (this.options.compatibilityAPI === 'v1')\n                return {\n                    ...{},\n                    ...this.getResource(lng, ns)\n                };\n            return this.getResource(lng, ns);\n        }\n        getDataByLanguage(lng) {\n            return this.data[lng];\n        }\n        toJSON() {\n            return this.data;\n        }\n    }\n    return ResourceStore;\n});\ndefine('skylark-i18next/postProcessor',[],function () {\n    'use strict';\n    return {\n        processors: {},\n        addPostProcessor(module) {\n            this.processors[module.name] = module;\n        },\n        handle(processors, value, key, options, translator) {\n            processors.forEach(processor => {\n                if (this.processors[processor])\n                    value = this.processors[processor].process(value, key, options, translator);\n            });\n            return value;\n        }\n    };\n});\ndefine('skylark-i18next/Translator',[\n    './logger',\n    './EventEmitter',\n    './postProcessor',\n    './utils'\n], function (baseLogger, EventEmitter, postProcessor, utils) {\n    'use strict';\n    const checkedLoadedFor = {};\n    class Translator extends EventEmitter {\n        constructor(services, options = {}) {\n            super();\n            if (utils.isIE10) {\n                EventEmitter.call(this);\n            }\n            utils.copy([\n                'resourceStore',\n                'languageUtils',\n                'pluralResolver',\n                'interpolator',\n                'backendConnector',\n                'i18nFormat',\n                'utils'\n            ], services, this);\n            this.options = options;\n            if (this.options.keySeparator === undefined) {\n                this.options.keySeparator = '.';\n            }\n            this.logger = baseLogger.create('translator');\n        }\n        changeLanguage(lng) {\n            if (lng)\n                this.language = lng;\n        }\n        exists(key, options = { interpolation: {} }) {\n            const resolved = this.resolve(key, options);\n            return resolved && resolved.res !== undefined;\n        }\n        extractFromKey(key, options) {\n            let nsSeparator = options.nsSeparator !== undefined ? options.nsSeparator : this.options.nsSeparator;\n            if (nsSeparator === undefined)\n                nsSeparator = ':';\n            const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n            let namespaces = options.ns || this.options.defaultNS;\n            if (nsSeparator && key.indexOf(nsSeparator) > -1) {\n                const m = key.match(this.interpolator.nestingRegexp);\n                if (m && m.length > 0) {\n                    return {\n                        key,\n                        namespaces\n                    };\n                }\n                const parts = key.split(nsSeparator);\n                if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1)\n                    namespaces = parts.shift();\n                key = parts.join(keySeparator);\n            }\n            if (typeof namespaces === 'string')\n                namespaces = [namespaces];\n            return {\n                key,\n                namespaces\n            };\n        }\n        translate(keys, options, lastKey) {\n            if (typeof options !== 'object' && this.options.overloadTranslationOptionHandler) {\n                options = this.options.overloadTranslationOptionHandler(arguments);\n            }\n            if (!options)\n                options = {};\n            if (keys === undefined || keys === null)\n                return '';\n            if (!Array.isArray(keys))\n                keys = [String(keys)];\n            const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n            const {key, namespaces} = this.extractFromKey(keys[keys.length - 1], options);\n            const namespace = namespaces[namespaces.length - 1];\n            const lng = options.lng || this.language;\n            const appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;\n            if (lng && lng.toLowerCase() === 'cimode') {\n                if (appendNamespaceToCIMode) {\n                    const nsSeparator = options.nsSeparator || this.options.nsSeparator;\n                    return namespace + nsSeparator + key;\n                }\n                return key;\n            }\n            const resolved = this.resolve(keys, options);\n            let res = resolved && resolved.res;\n            const resUsedKey = resolved && resolved.usedKey || key;\n            const resExactUsedKey = resolved && resolved.exactUsedKey || key;\n            const resType = Object.prototype.toString.apply(res);\n            const noObject = [\n                '[object Number]',\n                '[object Function]',\n                '[object RegExp]'\n            ];\n            const joinArrays = options.joinArrays !== undefined ? options.joinArrays : this.options.joinArrays;\n            const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;\n            const handleAsObject = typeof res !== 'string' && typeof res !== 'boolean' && typeof res !== 'number';\n            if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === 'string' && resType === '[object Array]')) {\n                if (!options.returnObjects && !this.options.returnObjects) {\n                    this.logger.warn('accessing an object - but returnObjects options is not enabled!');\n                    return this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, options) : `key '${ key } (${ this.language })' returned an object instead of string.`;\n                }\n                if (keySeparator) {\n                    const resTypeIsArray = resType === '[object Array]';\n                    const copy = resTypeIsArray ? [] : {};\n                    let newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;\n                    for (const m in res) {\n                        if (Object.prototype.hasOwnProperty.call(res, m)) {\n                            const deepKey = `${ newKeyToUse }${ keySeparator }${ m }`;\n                            copy[m] = this.translate(deepKey, {\n                                ...options,\n                                ...{\n                                    joinArrays: false,\n                                    ns: namespaces\n                                }\n                            });\n                            if (copy[m] === deepKey)\n                                copy[m] = res[m];\n                        }\n                    }\n                    res = copy;\n                }\n            } else if (handleAsObjectInI18nFormat && typeof joinArrays === 'string' && resType === '[object Array]') {\n                res = res.join(joinArrays);\n                if (res)\n                    res = this.extendTranslation(res, keys, options, lastKey);\n            } else {\n                let usedDefault = false;\n                let usedKey = false;\n                if (!this.isValidLookup(res) && options.defaultValue !== undefined) {\n                    usedDefault = true;\n                    if (options.count !== undefined) {\n                        const suffix = this.pluralResolver.getSuffix(lng, options.count);\n                        res = options[`defaultValue${ suffix }`];\n                    }\n                    if (!res)\n                        res = options.defaultValue;\n                }\n                if (!this.isValidLookup(res)) {\n                    usedKey = true;\n                    res = key;\n                }\n                const updateMissing = options.defaultValue && options.defaultValue !== res && this.options.updateMissing;\n                if (usedKey || usedDefault || updateMissing) {\n                    this.logger.log(updateMissing ? 'updateKey' : 'missingKey', lng, namespace, key, updateMissing ? options.defaultValue : res);\n                    if (keySeparator) {\n                        const fk = this.resolve(key, {\n                            ...options,\n                            keySeparator: false\n                        });\n                        if (fk && fk.res)\n                            this.logger.warn('Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.');\n                    }\n                    let lngs = [];\n                    const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);\n                    if (this.options.saveMissingTo === 'fallback' && fallbackLngs && fallbackLngs[0]) {\n                        for (let i = 0; i < fallbackLngs.length; i++) {\n                            lngs.push(fallbackLngs[i]);\n                        }\n                    } else if (this.options.saveMissingTo === 'all') {\n                        lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);\n                    } else {\n                        lngs.push(options.lng || this.language);\n                    }\n                    const send = (l, k) => {\n                        if (this.options.missingKeyHandler) {\n                            this.options.missingKeyHandler(l, namespace, k, updateMissing ? options.defaultValue : res, updateMissing, options);\n                        } else if (this.backendConnector && this.backendConnector.saveMissing) {\n                            this.backendConnector.saveMissing(l, namespace, k, updateMissing ? options.defaultValue : res, updateMissing, options);\n                        }\n                        this.emit('missingKey', l, namespace, k, res);\n                    };\n                    if (this.options.saveMissing) {\n                        const needsPluralHandling = options.count !== undefined && typeof options.count !== 'string';\n                        if (this.options.saveMissingPlurals && needsPluralHandling) {\n                            lngs.forEach(l => {\n                                const plurals = this.pluralResolver.getPluralFormsOfKey(l, key);\n                                plurals.forEach(p => send([l], p));\n                            });\n                        } else {\n                            send(lngs, key);\n                        }\n                    }\n                }\n                res = this.extendTranslation(res, keys, options, resolved, lastKey);\n                if (usedKey && res === key && this.options.appendNamespaceToMissingKey)\n                    res = `${ namespace }:${ key }`;\n                if (usedKey && this.options.parseMissingKeyHandler)\n                    res = this.options.parseMissingKeyHandler(res);\n            }\n            return res;\n        }\n        extendTranslation(res, key, options, resolved, lastKey) {\n            if (this.i18nFormat && this.i18nFormat.parse) {\n                res = this.i18nFormat.parse(res, options, resolved.usedLng, resolved.usedNS, resolved.usedKey, { resolved });\n            } else if (!options.skipInterpolation) {\n                if (options.interpolation)\n                    this.interpolator.init({\n                        ...options,\n                        ...{\n                            interpolation: {\n                                ...this.options.interpolation,\n                                ...options.interpolation\n                            }\n                        }\n                    });\n                const skipOnVariables = options.interpolation && options.interpolation.skipOnVariables || this.options.interpolation.skipOnVariables;\n                let nestBef;\n                if (skipOnVariables) {\n                    const nb = res.match(this.interpolator.nestingRegexp);\n                    nestBef = nb && nb.length;\n                }\n                let data = options.replace && typeof options.replace !== 'string' ? options.replace : options;\n                if (this.options.interpolation.defaultVariables)\n                    data = {\n                        ...this.options.interpolation.defaultVariables,\n                        ...data\n                    };\n                res = this.interpolator.interpolate(res, data, options.lng || this.language, options);\n                if (skipOnVariables) {\n                    const na = res.match(this.interpolator.nestingRegexp);\n                    const nestAft = na && na.length;\n                    if (nestBef < nestAft)\n                        options.nest = false;\n                }\n                if (options.nest !== false)\n                    res = this.interpolator.nest(res, (...args) => {\n                        if (lastKey && lastKey[0] === args[0]) {\n                            this.logger.warn(`It seems you are nesting recursively key: ${ args[0] } in key: ${ key[0] }`);\n                            return null;\n                        }\n                        return this.translate(...args, key);\n                    }, options);\n                if (options.interpolation)\n                    this.interpolator.reset();\n            }\n            const postProcess = options.postProcess || this.options.postProcess;\n            const postProcessorNames = typeof postProcess === 'string' ? [postProcess] : postProcess;\n            if (res !== undefined && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {\n                res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? {\n                    i18nResolved: resolved,\n                    ...options\n                } : options, this);\n            }\n            return res;\n        }\n        resolve(keys, options = {}) {\n            let found;\n            let usedKey;\n            let exactUsedKey;\n            let usedLng;\n            let usedNS;\n            if (typeof keys === 'string')\n                keys = [keys];\n            keys.forEach(k => {\n                if (this.isValidLookup(found))\n                    return;\n                const extracted = this.extractFromKey(k, options);\n                const key = extracted.key;\n                usedKey = key;\n                let namespaces = extracted.namespaces;\n                if (this.options.fallbackNS)\n                    namespaces = namespaces.concat(this.options.fallbackNS);\n                const needsPluralHandling = options.count !== undefined && typeof options.count !== 'string';\n                const needsContextHandling = options.context !== undefined && typeof options.context === 'string' && options.context !== '';\n                const codes = options.lngs ? options.lngs : this.languageUtils.toResolveHierarchy(options.lng || this.language, options.fallbackLng);\n                namespaces.forEach(ns => {\n                    if (this.isValidLookup(found))\n                        return;\n                    usedNS = ns;\n                    if (!checkedLoadedFor[`${ codes[0] }-${ ns }`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(usedNS)) {\n                        checkedLoadedFor[`${ codes[0] }-${ ns }`] = true;\n                        this.logger.warn(`key \"${ usedKey }\" for languages \"${ codes.join(', ') }\" won't get resolved as namespace \"${ usedNS }\" was not yet loaded`, 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');\n                    }\n                    codes.forEach(code => {\n                        if (this.isValidLookup(found))\n                            return;\n                        usedLng = code;\n                        let finalKey = key;\n                        const finalKeys = [finalKey];\n                        if (this.i18nFormat && this.i18nFormat.addLookupKeys) {\n                            this.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);\n                        } else {\n                            let pluralSuffix;\n                            if (needsPluralHandling)\n                                pluralSuffix = this.pluralResolver.getSuffix(code, options.count);\n                            if (needsPluralHandling && needsContextHandling)\n                                finalKeys.push(finalKey + pluralSuffix);\n                            if (needsContextHandling)\n                                finalKeys.push(finalKey += `${ this.options.contextSeparator }${ options.context }`);\n                            if (needsPluralHandling)\n                                finalKeys.push(finalKey += pluralSuffix);\n                        }\n                        let possibleKey;\n                        while (possibleKey = finalKeys.pop()) {\n                            if (!this.isValidLookup(found)) {\n                                exactUsedKey = possibleKey;\n                                found = this.getResource(code, ns, possibleKey, options);\n                            }\n                        }\n                    });\n                });\n            });\n            return {\n                res: found,\n                usedKey,\n                exactUsedKey,\n                usedLng,\n                usedNS\n            };\n        }\n        isValidLookup(res) {\n            return res !== undefined && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === '');\n        }\n        getResource(code, ns, key, options = {}) {\n            if (this.i18nFormat && this.i18nFormat.getResource)\n                return this.i18nFormat.getResource(code, ns, key, options);\n            return this.resourceStore.getResource(code, ns, key, options);\n        }\n    }\n    return Translator;\n});\ndefine('skylark-i18next/LanguageUtils',['./logger'], function (baseLogger) {\n    'use strict';\n    function capitalize(string) {\n        return string.charAt(0).toUpperCase() + string.slice(1);\n    }\n    class LanguageUtil {\n        constructor(options) {\n            this.options = options;\n            this.whitelist = this.options.supportedLngs || false;\n            this.supportedLngs = this.options.supportedLngs || false;\n            this.logger = baseLogger.create('languageUtils');\n        }\n        getScriptPartFromCode(code) {\n            if (!code || code.indexOf('-') < 0)\n                return null;\n            const p = code.split('-');\n            if (p.length === 2)\n                return null;\n            p.pop();\n            if (p[p.length - 1].toLowerCase() === 'x')\n                return null;\n            return this.formatLanguageCode(p.join('-'));\n        }\n        getLanguagePartFromCode(code) {\n            if (!code || code.indexOf('-') < 0)\n                return code;\n            const p = code.split('-');\n            return this.formatLanguageCode(p[0]);\n        }\n        formatLanguageCode(code) {\n            if (typeof code === 'string' && code.indexOf('-') > -1) {\n                const specialCases = [\n                    'hans',\n                    'hant',\n                    'latn',\n                    'cyrl',\n                    'cans',\n                    'mong',\n                    'arab'\n                ];\n                let p = code.split('-');\n                if (this.options.lowerCaseLng) {\n                    p = p.map(part => part.toLowerCase());\n                } else if (p.length === 2) {\n                    p[0] = p[0].toLowerCase();\n                    p[1] = p[1].toUpperCase();\n                    if (specialCases.indexOf(p[1].toLowerCase()) > -1)\n                        p[1] = capitalize(p[1].toLowerCase());\n                } else if (p.length === 3) {\n                    p[0] = p[0].toLowerCase();\n                    if (p[1].length === 2)\n                        p[1] = p[1].toUpperCase();\n                    if (p[0] !== 'sgn' && p[2].length === 2)\n                        p[2] = p[2].toUpperCase();\n                    if (specialCases.indexOf(p[1].toLowerCase()) > -1)\n                        p[1] = capitalize(p[1].toLowerCase());\n                    if (specialCases.indexOf(p[2].toLowerCase()) > -1)\n                        p[2] = capitalize(p[2].toLowerCase());\n                }\n                return p.join('-');\n            }\n            return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;\n        }\n        isWhitelisted(code) {\n            this.logger.deprecate('languageUtils.isWhitelisted', 'function \"isWhitelisted\" will be renamed to \"isSupportedCode\" in the next major - please make sure to rename it\\'s usage asap.');\n            return this.isSupportedCode(code);\n        }\n        isSupportedCode(code) {\n            if (this.options.load === 'languageOnly' || this.options.nonExplicitSupportedLngs) {\n                code = this.getLanguagePartFromCode(code);\n            }\n            return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;\n        }\n        getBestMatchFromCodes(codes) {\n            if (!codes)\n                return null;\n            let found;\n            codes.forEach(code => {\n                if (found)\n                    return;\n                let cleanedLng = this.formatLanguageCode(code);\n                if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng))\n                    found = cleanedLng;\n            });\n            if (!found && this.options.supportedLngs) {\n                codes.forEach(code => {\n                    if (found)\n                        return;\n                    let lngOnly = this.getLanguagePartFromCode(code);\n                    if (this.isSupportedCode(lngOnly))\n                        return found = lngOnly;\n                    found = this.options.supportedLngs.find(supportedLng => {\n                        if (supportedLng.indexOf(lngOnly) === 0)\n                            return supportedLng;\n                    });\n                });\n            }\n            if (!found)\n                found = this.getFallbackCodes(this.options.fallbackLng)[0];\n            return found;\n        }\n        getFallbackCodes(fallbacks, code) {\n            if (!fallbacks)\n                return [];\n            if (typeof fallbacks === 'string')\n                fallbacks = [fallbacks];\n            if (Object.prototype.toString.apply(fallbacks) === '[object Array]')\n                return fallbacks;\n            if (!code)\n                return fallbacks.default || [];\n            let found = fallbacks[code];\n            if (!found)\n                found = fallbacks[this.getScriptPartFromCode(code)];\n            if (!found)\n                found = fallbacks[this.formatLanguageCode(code)];\n            if (!found)\n                found = fallbacks[this.getLanguagePartFromCode(code)];\n            if (!found)\n                found = fallbacks.default;\n            return found || [];\n        }\n        toResolveHierarchy(code, fallbackCode) {\n            const fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);\n            const codes = [];\n            const addCode = c => {\n                if (!c)\n                    return;\n                if (this.isSupportedCode(c)) {\n                    codes.push(c);\n                } else {\n                    this.logger.warn(`rejecting language code not found in supportedLngs: ${ c }`);\n                }\n            };\n            if (typeof code === 'string' && code.indexOf('-') > -1) {\n                if (this.options.load !== 'languageOnly')\n                    addCode(this.formatLanguageCode(code));\n                if (this.options.load !== 'languageOnly' && this.options.load !== 'currentOnly')\n                    addCode(this.getScriptPartFromCode(code));\n                if (this.options.load !== 'currentOnly')\n                    addCode(this.getLanguagePartFromCode(code));\n            } else if (typeof code === 'string') {\n                addCode(this.formatLanguageCode(code));\n            }\n            fallbackCodes.forEach(fc => {\n                if (codes.indexOf(fc) < 0)\n                    addCode(this.formatLanguageCode(fc));\n            });\n            return codes;\n        }\n    }\n    return LanguageUtil;\n});\ndefine('skylark-i18next/PluralResolver',['./logger'], function (baseLogger) {\n    'use strict';\n    let sets = [\n        {\n            lngs: [\n                'ach',\n                'ak',\n                'am',\n                'arn',\n                'br',\n                'fil',\n                'gun',\n                'ln',\n                'mfe',\n                'mg',\n                'mi',\n                'oc',\n                'pt',\n                'pt-BR',\n                'tg',\n                'ti',\n                'tr',\n                'uz',\n                'wa'\n            ],\n            nr: [\n                1,\n                2\n            ],\n            fc: 1\n        },\n        {\n            lngs: [\n                'af',\n                'an',\n                'ast',\n                'az',\n                'bg',\n                'bn',\n                'ca',\n                'da',\n                'de',\n                'dev',\n                'el',\n                'en',\n                'eo',\n                'es',\n                'et',\n                'eu',\n                'fi',\n                'fo',\n                'fur',\n                'fy',\n                'gl',\n                'gu',\n                'ha',\n                'hi',\n                'hu',\n                'hy',\n                'ia',\n                'it',\n                'kn',\n                'ku',\n                'lb',\n                'mai',\n                'ml',\n                'mn',\n                'mr',\n                'nah',\n                'nap',\n                'nb',\n                'ne',\n                'nl',\n                'nn',\n                'no',\n                'nso',\n                'pa',\n                'pap',\n                'pms',\n                'ps',\n                'pt-PT',\n                'rm',\n                'sco',\n                'se',\n                'si',\n                'so',\n                'son',\n                'sq',\n                'sv',\n                'sw',\n                'ta',\n                'te',\n                'tk',\n                'ur',\n                'yo'\n            ],\n            nr: [\n                1,\n                2\n            ],\n            fc: 2\n        },\n        {\n            lngs: [\n                'ay',\n                'bo',\n                'cgg',\n                'fa',\n                'ht',\n                'id',\n                'ja',\n                'jbo',\n                'ka',\n                'kk',\n                'km',\n                'ko',\n                'ky',\n                'lo',\n                'ms',\n                'sah',\n                'su',\n                'th',\n                'tt',\n                'ug',\n                'vi',\n                'wo',\n                'zh'\n            ],\n            nr: [1],\n            fc: 3\n        },\n        {\n            lngs: [\n                'be',\n                'bs',\n                'cnr',\n                'dz',\n                'hr',\n                'ru',\n                'sr',\n                'uk'\n            ],\n            nr: [\n                1,\n                2,\n                5\n            ],\n            fc: 4\n        },\n        {\n            lngs: ['ar'],\n            nr: [\n                0,\n                1,\n                2,\n                3,\n                11,\n                100\n            ],\n            fc: 5\n        },\n        {\n            lngs: [\n                'cs',\n                'sk'\n            ],\n            nr: [\n                1,\n                2,\n                5\n            ],\n            fc: 6\n        },\n        {\n            lngs: [\n                'csb',\n                'pl'\n            ],\n            nr: [\n                1,\n                2,\n                5\n            ],\n            fc: 7\n        },\n        {\n            lngs: ['cy'],\n            nr: [\n                1,\n                2,\n                3,\n                8\n            ],\n            fc: 8\n        },\n        {\n            lngs: ['fr'],\n            nr: [\n                1,\n                2\n            ],\n            fc: 9\n        },\n        {\n            lngs: ['ga'],\n            nr: [\n                1,\n                2,\n                3,\n                7,\n                11\n            ],\n            fc: 10\n        },\n        {\n            lngs: ['gd'],\n            nr: [\n                1,\n                2,\n                3,\n                20\n            ],\n            fc: 11\n        },\n        {\n            lngs: ['is'],\n            nr: [\n                1,\n                2\n            ],\n            fc: 12\n        },\n        {\n            lngs: ['jv'],\n            nr: [\n                0,\n                1\n            ],\n            fc: 13\n        },\n        {\n            lngs: ['kw'],\n            nr: [\n                1,\n                2,\n                3,\n                4\n            ],\n            fc: 14\n        },\n        {\n            lngs: ['lt'],\n            nr: [\n                1,\n                2,\n                10\n            ],\n            fc: 15\n        },\n        {\n            lngs: ['lv'],\n            nr: [\n                1,\n                2,\n                0\n            ],\n            fc: 16\n        },\n        {\n            lngs: ['mk'],\n            nr: [\n                1,\n                2\n            ],\n            fc: 17\n        },\n        {\n            lngs: ['mnk'],\n            nr: [\n                0,\n                1,\n                2\n            ],\n            fc: 18\n        },\n        {\n            lngs: ['mt'],\n            nr: [\n                1,\n                2,\n                11,\n                20\n            ],\n            fc: 19\n        },\n        {\n            lngs: ['or'],\n            nr: [\n                2,\n                1\n            ],\n            fc: 2\n        },\n        {\n            lngs: ['ro'],\n            nr: [\n                1,\n                2,\n                20\n            ],\n            fc: 20\n        },\n        {\n            lngs: ['sl'],\n            nr: [\n                5,\n                1,\n                2,\n                3\n            ],\n            fc: 21\n        },\n        {\n            lngs: [\n                'he',\n                'iw'\n            ],\n            nr: [\n                1,\n                2,\n                20,\n                21\n            ],\n            fc: 22\n        }\n    ];\n    let _rulesPluralsTypes = {\n        1: function (n) {\n            return Number(n > 1);\n        },\n        2: function (n) {\n            return Number(n != 1);\n        },\n        3: function (n) {\n            return 0;\n        },\n        4: function (n) {\n            return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);\n        },\n        5: function (n) {\n            return Number(n == 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5);\n        },\n        6: function (n) {\n            return Number(n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2);\n        },\n        7: function (n) {\n            return Number(n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);\n        },\n        8: function (n) {\n            return Number(n == 1 ? 0 : n == 2 ? 1 : n != 8 && n != 11 ? 2 : 3);\n        },\n        9: function (n) {\n            return Number(n >= 2);\n        },\n        10: function (n) {\n            return Number(n == 1 ? 0 : n == 2 ? 1 : n < 7 ? 2 : n < 11 ? 3 : 4);\n        },\n        11: function (n) {\n            return Number(n == 1 || n == 11 ? 0 : n == 2 || n == 12 ? 1 : n > 2 && n < 20 ? 2 : 3);\n        },\n        12: function (n) {\n            return Number(n % 10 != 1 || n % 100 == 11);\n        },\n        13: function (n) {\n            return Number(n !== 0);\n        },\n        14: function (n) {\n            return Number(n == 1 ? 0 : n == 2 ? 1 : n == 3 ? 2 : 3);\n        },\n        15: function (n) {\n            return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);\n        },\n        16: function (n) {\n            return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n !== 0 ? 1 : 2);\n        },\n        17: function (n) {\n            return Number(n == 1 || n % 10 == 1 && n % 100 != 11 ? 0 : 1);\n        },\n        18: function (n) {\n            return Number(n == 0 ? 0 : n == 1 ? 1 : 2);\n        },\n        19: function (n) {\n            return Number(n == 1 ? 0 : n == 0 || n % 100 > 1 && n % 100 < 11 ? 1 : n % 100 > 10 && n % 100 < 20 ? 2 : 3);\n        },\n        20: function (n) {\n            return Number(n == 1 ? 0 : n == 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2);\n        },\n        21: function (n) {\n            return Number(n % 100 == 1 ? 1 : n % 100 == 2 ? 2 : n % 100 == 3 || n % 100 == 4 ? 3 : 0);\n        },\n        22: function (n) {\n            return Number(n == 1 ? 0 : n == 2 ? 1 : (n < 0 || n > 10) && n % 10 == 0 ? 2 : 3);\n        }\n    };\n    function createRules() {\n        const rules = {};\n        sets.forEach(set => {\n            set.lngs.forEach(l => {\n                rules[l] = {\n                    numbers: set.nr,\n                    plurals: _rulesPluralsTypes[set.fc]\n                };\n            });\n        });\n        return rules;\n    }\n    class PluralResolver {\n        constructor(languageUtils, options = {}) {\n            this.languageUtils = languageUtils;\n            this.options = options;\n            this.logger = baseLogger.create('pluralResolver');\n            this.rules = createRules();\n        }\n        addRule(lng, obj) {\n            this.rules[lng] = obj;\n        }\n        getRule(code) {\n            return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];\n        }\n        needsPlural(code) {\n            const rule = this.getRule(code);\n            return rule && rule.numbers.length > 1;\n        }\n        getPluralFormsOfKey(code, key) {\n            const ret = [];\n            const rule = this.getRule(code);\n            if (!rule)\n                return ret;\n            rule.numbers.forEach(n => {\n                const suffix = this.getSuffix(code, n);\n                ret.push(`${ key }${ suffix }`);\n            });\n            return ret;\n        }\n        getSuffix(code, count) {\n            const rule = this.getRule(code);\n            if (rule) {\n                const idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));\n                let suffix = rule.numbers[idx];\n                if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {\n                    if (suffix === 2) {\n                        suffix = 'plural';\n                    } else if (suffix === 1) {\n                        suffix = '';\n                    }\n                }\n                const returnSuffix = () => this.options.prepend && suffix.toString() ? this.options.prepend + suffix.toString() : suffix.toString();\n                if (this.options.compatibilityJSON === 'v1') {\n                    if (suffix === 1)\n                        return '';\n                    if (typeof suffix === 'number')\n                        return `_plural_${ suffix.toString() }`;\n                    return returnSuffix();\n                } else if (this.options.compatibilityJSON === 'v2') {\n                    return returnSuffix();\n                } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {\n                    return returnSuffix();\n                }\n                return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();\n            }\n            this.logger.warn(`no plural rule found for: ${ code }`);\n            return '';\n        }\n    }\n    return PluralResolver;\n});\ndefine('skylark-i18next/Interpolator',[\n    './utils',\n    './logger'\n], function (utils, baseLogger) {\n    'use strict';\n    class Interpolator {\n        constructor(options = {}) {\n            this.logger = baseLogger.create('interpolator');\n            this.options = options;\n            this.format = options.interpolation && options.interpolation.format || (value => value);\n            this.init(options);\n        }\n        init(options = {}) {\n            if (!options.interpolation)\n                options.interpolation = { escapeValue: true };\n            const iOpts = options.interpolation;\n            this.escape = iOpts.escape !== undefined ? iOpts.escape : utils.escape;\n            this.escapeValue = iOpts.escapeValue !== undefined ? iOpts.escapeValue : true;\n            this.useRawValueToEscape = iOpts.useRawValueToEscape !== undefined ? iOpts.useRawValueToEscape : false;\n            this.prefix = iOpts.prefix ? utils.regexEscape(iOpts.prefix) : iOpts.prefixEscaped || '{{';\n            this.suffix = iOpts.suffix ? utils.regexEscape(iOpts.suffix) : iOpts.suffixEscaped || '}}';\n            this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ',';\n            this.unescapePrefix = iOpts.unescapeSuffix ? '' : iOpts.unescapePrefix || '-';\n            this.unescapeSuffix = this.unescapePrefix ? '' : iOpts.unescapeSuffix || '';\n            this.nestingPrefix = iOpts.nestingPrefix ? utils.regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || utils.regexEscape('$t(');\n            this.nestingSuffix = iOpts.nestingSuffix ? utils.regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || utils.regexEscape(')');\n            this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || ',';\n            this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1000;\n            this.alwaysFormat = iOpts.alwaysFormat !== undefined ? iOpts.alwaysFormat : false;\n            this.resetRegExp();\n        }\n        reset() {\n            if (this.options)\n                this.init(this.options);\n        }\n        resetRegExp() {\n            const regexpStr = `${ this.prefix }(.+?)${ this.suffix }`;\n            this.regexp = new RegExp(regexpStr, 'g');\n            const regexpUnescapeStr = `${ this.prefix }${ this.unescapePrefix }(.+?)${ this.unescapeSuffix }${ this.suffix }`;\n            this.regexpUnescape = new RegExp(regexpUnescapeStr, 'g');\n            const nestingRegexpStr = `${ this.nestingPrefix }(.+?)${ this.nestingSuffix }`;\n            this.nestingRegexp = new RegExp(nestingRegexpStr, 'g');\n        }\n        interpolate(str, data, lng, options) {\n            let match;\n            let value;\n            let replaces;\n            const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};\n            function regexSafe(val) {\n                return val.replace(/\\$/g, '$$$$');\n            }\n            const handleFormat = key => {\n                if (key.indexOf(this.formatSeparator) < 0) {\n                    const path = utils.getPathWithDefaults(data, defaultData, key);\n                    return this.alwaysFormat ? this.format(path, undefined, lng) : path;\n                }\n                const p = key.split(this.formatSeparator);\n                const k = p.shift().trim();\n                const f = p.join(this.formatSeparator).trim();\n                return this.format(utils.getPathWithDefaults(data, defaultData, k), f, lng, options);\n            };\n            this.resetRegExp();\n            const missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;\n            const skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables || this.options.interpolation.skipOnVariables;\n            const todos = [\n                {\n                    regex: this.regexpUnescape,\n                    safeValue: val => regexSafe(val)\n                },\n                {\n                    regex: this.regexp,\n                    safeValue: val => this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val)\n                }\n            ];\n            todos.forEach(todo => {\n                replaces = 0;\n                while (match = todo.regex.exec(str)) {\n                    value = handleFormat(match[1].trim());\n                    if (value === undefined) {\n                        if (typeof missingInterpolationHandler === 'function') {\n                            const temp = missingInterpolationHandler(str, match, options);\n                            value = typeof temp === 'string' ? temp : '';\n                        } else if (skipOnVariables) {\n                            value = match[0];\n                            continue;\n                        } else {\n                            this.logger.warn(`missed to pass in variable ${ match[1] } for interpolating ${ str }`);\n                            value = '';\n                        }\n                    } else if (typeof value !== 'string' && !this.useRawValueToEscape) {\n                        value = utils.makeString(value);\n                    }\n                    str = str.replace(match[0], todo.safeValue(value));\n                    todo.regex.lastIndex = 0;\n                    replaces++;\n                    if (replaces >= this.maxReplaces) {\n                        break;\n                    }\n                }\n            });\n            return str;\n        }\n        nest(str, fc, options = {}) {\n            let match;\n            let value;\n            let clonedOptions = { ...options };\n            clonedOptions.applyPostProcessor = false;\n            delete clonedOptions.defaultValue;\n            function handleHasOptions(key, inheritedOptions) {\n                const sep = this.nestingOptionsSeparator;\n                if (key.indexOf(sep) < 0)\n                    return key;\n                const c = key.split(new RegExp(`${ sep }[ ]*{`));\n                let optionsString = `{${ c[1] }`;\n                key = c[0];\n                optionsString = this.interpolate(optionsString, clonedOptions);\n                optionsString = optionsString.replace(/'/g, '\"');\n                try {\n                    clonedOptions = JSON.parse(optionsString);\n                    if (inheritedOptions)\n                        clonedOptions = {\n                            ...inheritedOptions,\n                            ...clonedOptions\n                        };\n                } catch (e) {\n                    this.logger.warn(`failed parsing options string in nesting for key ${ key }`, e);\n                    return `${ key }${ sep }${ optionsString }`;\n                }\n                delete clonedOptions.defaultValue;\n                return key;\n            }\n            while (match = this.nestingRegexp.exec(str)) {\n                let formatters = [];\n                let doReduce = false;\n                if (match[0].includes(this.formatSeparator) && !/{.*}/.test(match[1])) {\n                    const r = match[1].split(this.formatSeparator).map(elem => elem.trim());\n                    match[1] = r.shift();\n                    formatters = r;\n                    doReduce = true;\n                }\n                value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);\n                if (value && match[0] === str && typeof value !== 'string')\n                    return value;\n                if (typeof value !== 'string')\n                    value = utils.makeString(value);\n                if (!value) {\n                    this.logger.warn(`missed to resolve ${ match[1] } for nesting ${ str }`);\n                    value = '';\n                }\n                if (doReduce) {\n                    value = formatters.reduce((v, f) => this.format(v, f, options.lng, options), value.trim());\n                }\n                str = str.replace(match[0], value);\n                this.regexp.lastIndex = 0;\n            }\n            return str;\n        }\n    }\n    return Interpolator;\n});\ndefine('skylark-i18next/BackendConnector',[\n    './utils',\n    './logger',\n    './EventEmitter'\n], function (utils, baseLogger, EventEmitter) {\n    'use strict';\n    function remove(arr, what) {\n        let found = arr.indexOf(what);\n        while (found !== -1) {\n            arr.splice(found, 1);\n            found = arr.indexOf(what);\n        }\n    }\n    class Connector extends EventEmitter {\n        constructor(backend, store, services, options = {}) {\n            super();\n            if (utils.isIE10) {\n                EventEmitter.call(this);\n            }\n            this.backend = backend;\n            this.store = store;\n            this.services = services;\n            this.languageUtils = services.languageUtils;\n            this.options = options;\n            this.logger = baseLogger.create('backendConnector');\n            this.state = {};\n            this.queue = [];\n            if (this.backend && this.backend.init) {\n                this.backend.init(services, options.backend, options);\n            }\n        }\n        queueLoad(languages, namespaces, options, callback) {\n            const toLoad = [];\n            const pending = [];\n            const toLoadLanguages = [];\n            const toLoadNamespaces = [];\n            languages.forEach(lng => {\n                let hasAllNamespaces = true;\n                namespaces.forEach(ns => {\n                    const name = `${ lng }|${ ns }`;\n                    if (!options.reload && this.store.hasResourceBundle(lng, ns)) {\n                        this.state[name] = 2;\n                    } else if (this.state[name] < 0) {\n                    } else if (this.state[name] === 1) {\n                        if (pending.indexOf(name) < 0)\n                            pending.push(name);\n                    } else {\n                        this.state[name] = 1;\n                        hasAllNamespaces = false;\n                        if (pending.indexOf(name) < 0)\n                            pending.push(name);\n                        if (toLoad.indexOf(name) < 0)\n                            toLoad.push(name);\n                        if (toLoadNamespaces.indexOf(ns) < 0)\n                            toLoadNamespaces.push(ns);\n                    }\n                });\n                if (!hasAllNamespaces)\n                    toLoadLanguages.push(lng);\n            });\n            if (toLoad.length || pending.length) {\n                this.queue.push({\n                    pending,\n                    loaded: {},\n                    errors: [],\n                    callback\n                });\n            }\n            return {\n                toLoad,\n                pending,\n                toLoadLanguages,\n                toLoadNamespaces\n            };\n        }\n        loaded(name, err, data) {\n            const s = name.split('|');\n            const lng = s[0];\n            const ns = s[1];\n            if (err)\n                this.emit('failedLoading', lng, ns, err);\n            if (data) {\n                this.store.addResourceBundle(lng, ns, data);\n            }\n            this.state[name] = err ? -1 : 2;\n            const loaded = {};\n            this.queue.forEach(q => {\n                utils.pushPath(q.loaded, [lng], ns);\n                remove(q.pending, name);\n                if (err)\n                    q.errors.push(err);\n                if (q.pending.length === 0 && !q.done) {\n                    Object.keys(q.loaded).forEach(l => {\n                        if (!loaded[l])\n                            loaded[l] = [];\n                        if (q.loaded[l].length) {\n                            q.loaded[l].forEach(ns => {\n                                if (loaded[l].indexOf(ns) < 0)\n                                    loaded[l].push(ns);\n                            });\n                        }\n                    });\n                    q.done = true;\n                    if (q.errors.length) {\n                        q.callback(q.errors);\n                    } else {\n                        q.callback();\n                    }\n                }\n            });\n            this.emit('loaded', loaded);\n            this.queue = this.queue.filter(q => !q.done);\n        }\n        read(lng, ns, fcName, tried = 0, wait = 350, callback) {\n            if (!lng.length)\n                return callback(null, {});\n            return this.backend[fcName](lng, ns, (err, data) => {\n                if (err && data && tried < 5) {\n                    setTimeout(() => {\n                        this.read.call(this, lng, ns, fcName, tried + 1, wait * 2, callback);\n                    }, wait);\n                    return;\n                }\n                callback(err, data);\n            });\n        }\n        prepareLoading(languages, namespaces, options = {}, callback) {\n            if (!this.backend) {\n                this.logger.warn('No backend was added via i18next.use. Will not load resources.');\n                return callback && callback();\n            }\n            if (typeof languages === 'string')\n                languages = this.languageUtils.toResolveHierarchy(languages);\n            if (typeof namespaces === 'string')\n                namespaces = [namespaces];\n            const toLoad = this.queueLoad(languages, namespaces, options, callback);\n            if (!toLoad.toLoad.length) {\n                if (!toLoad.pending.length)\n                    callback();\n                return null;\n            }\n            toLoad.toLoad.forEach(name => {\n                this.loadOne(name);\n            });\n        }\n        load(languages, namespaces, callback) {\n            this.prepareLoading(languages, namespaces, {}, callback);\n        }\n        reload(languages, namespaces, callback) {\n            this.prepareLoading(languages, namespaces, { reload: true }, callback);\n        }\n        loadOne(name, prefix = '') {\n            const s = name.split('|');\n            const lng = s[0];\n            const ns = s[1];\n            this.read(lng, ns, 'read', undefined, undefined, (err, data) => {\n                if (err)\n                    this.logger.warn(`${ prefix }loading namespace ${ ns } for language ${ lng } failed`, err);\n                if (!err && data)\n                    this.logger.log(`${ prefix }loaded namespace ${ ns } for language ${ lng }`, data);\n                this.loaded(name, err, data);\n            });\n        }\n        saveMissing(languages, namespace, key, fallbackValue, isUpdate, options = {}) {\n            if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {\n                this.logger.warn(`did not save key \"${ key }\" as the namespace \"${ namespace }\" was not yet loaded`, 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');\n                return;\n            }\n            if (key === undefined || key === null || key === '')\n                return;\n            if (this.backend && this.backend.create) {\n                this.backend.create(languages, namespace, key, fallbackValue, null, {\n                    ...options,\n                    isUpdate\n                });\n            }\n            if (!languages || !languages[0])\n                return;\n            this.store.addResource(languages[0], namespace, key, fallbackValue);\n        }\n    }\n    return Connector;\n});\ndefine('skylark-i18next/defaults',[],function () {\n    'use strict';\n    function get() {\n        return {\n            debug: false,\n            initImmediate: true,\n            ns: ['translation'],\n            defaultNS: ['translation'],\n            fallbackLng: ['dev'],\n            fallbackNS: false,\n            whitelist: false,\n            nonExplicitWhitelist: false,\n            supportedLngs: false,\n            nonExplicitSupportedLngs: false,\n            load: 'all',\n            preload: false,\n            simplifyPluralSuffix: true,\n            keySeparator: '.',\n            nsSeparator: ':',\n            pluralSeparator: '_',\n            contextSeparator: '_',\n            partialBundledLanguages: false,\n            saveMissing: false,\n            updateMissing: false,\n            saveMissingTo: 'fallback',\n            saveMissingPlurals: true,\n            missingKeyHandler: false,\n            missingInterpolationHandler: false,\n            postProcess: false,\n            postProcessPassResolved: false,\n            returnNull: true,\n            returnEmptyString: true,\n            returnObjects: false,\n            joinArrays: false,\n            returnedObjectHandler: false,\n            parseMissingKeyHandler: false,\n            appendNamespaceToMissingKey: false,\n            appendNamespaceToCIMode: false,\n            overloadTranslationOptionHandler: function handle(args) {\n                var ret = {};\n                if (typeof args[1] === 'object')\n                    ret = args[1];\n                if (typeof args[1] === 'string')\n                    ret.defaultValue = args[1];\n                if (typeof args[2] === 'string')\n                    ret.tDescription = args[2];\n                if (typeof args[2] === 'object' || typeof args[3] === 'object') {\n                    var options = args[3] || args[2];\n                    Object.keys(options).forEach(function (key) {\n                        ret[key] = options[key];\n                    });\n                }\n                return ret;\n            },\n            interpolation: {\n                escapeValue: true,\n                format: (value, format, lng, options) => value,\n                prefix: '{{',\n                suffix: '}}',\n                formatSeparator: ',',\n                unescapePrefix: '-',\n                nestingPrefix: '$t(',\n                nestingSuffix: ')',\n                nestingOptionsSeparator: ',',\n                maxReplaces: 1000,\n                skipOnVariables: false\n            }\n        };\n    }\n    \n    function transformOptions(options) {\n        if (typeof options.ns === 'string')\n            options.ns = [options.ns];\n        if (typeof options.fallbackLng === 'string')\n            options.fallbackLng = [options.fallbackLng];\n        if (typeof options.fallbackNS === 'string')\n            options.fallbackNS = [options.fallbackNS];\n        if (options.whitelist) {\n            if (options.whitelist && options.whitelist.indexOf('cimode') < 0) {\n                options.whitelist = options.whitelist.concat(['cimode']);\n            }\n            options.supportedLngs = options.whitelist;\n        }\n        if (options.nonExplicitWhitelist) {\n            options.nonExplicitSupportedLngs = options.nonExplicitWhitelist;\n        }\n        if (options.supportedLngs && options.supportedLngs.indexOf('cimode') < 0) {\n            options.supportedLngs = options.supportedLngs.concat(['cimode']);\n        }\n        return options;\n    }\n\n    return {\n        get: get,\n        transformOptions: transformOptions\n    };\n});\ndefine('skylark-i18next/i18next',[\n    './logger',\n    './EventEmitter',\n    './ResourceStore',\n    './Translator',\n    './LanguageUtils',\n    './PluralResolver',\n    './Interpolator',\n    './BackendConnector',\n    './defaults',\n    './postProcessor',\n    './utils'\n], function (baseLogger, EventEmitter, ResourceStore, Translator, LanguageUtils, PluralResolver, Interpolator, BackendConnector, defaults,  postProcessor, utils) {\n    'use strict';\n    function noop() {\n    }\n    class I18n extends EventEmitter {\n        constructor(options = {}, callback) {\n            super();\n            if (utils.isIE10) {\n                EventEmitter.call(this);\n            }\n            this.options = defaults.transformOptions(options);\n            this.services = {};\n            this.logger = baseLogger;\n            this.modules = { external: [] };\n            if (callback && !this.isInitialized && !options.isClone) {\n                if (!this.options.initImmediate) {\n                    this.init(options, callback);\n                    return this;\n                }\n                setTimeout(() => {\n                    this.init(options, callback);\n                }, 0);\n            }\n        }\n        init(options = {}, callback) {\n            if (typeof options === 'function') {\n                callback = options;\n                options = {};\n            }\n            if (options.whitelist && !options.supportedLngs) {\n                this.logger.deprecate('whitelist', 'option \"whitelist\" will be renamed to \"supportedLngs\" in the next major - please make sure to rename this option asap.');\n            }\n            if (options.nonExplicitWhitelist && !options.nonExplicitSupportedLngs) {\n                this.logger.deprecate('whitelist', 'options \"nonExplicitWhitelist\" will be renamed to \"nonExplicitSupportedLngs\" in the next major - please make sure to rename this option asap.');\n            }\n            this.options = {\n                ...defaults.get(),\n                ...this.options,\n                ...defaults.transformOptions(options)\n            };\n            this.format = this.options.interpolation.format;\n            if (!callback)\n                callback = noop;\n            function createClassOnDemand(ClassOrObject) {\n                if (!ClassOrObject)\n                    return null;\n                if (typeof ClassOrObject === 'function')\n                    return new ClassOrObject();\n                return ClassOrObject;\n            }\n            if (!this.options.isClone) {\n                if (this.modules.logger) {\n                    baseLogger.init(createClassOnDemand(this.modules.logger), this.options);\n                } else {\n                    baseLogger.init(null, this.options);\n                }\n                const lu = new LanguageUtils(this.options);\n                this.store = new ResourceStore(this.options.resources, this.options);\n                const s = this.services;\n                s.logger = baseLogger;\n                s.resourceStore = this.store;\n                s.languageUtils = lu;\n                s.pluralResolver = new PluralResolver(lu, {\n                    prepend: this.options.pluralSeparator,\n                    compatibilityJSON: this.options.compatibilityJSON,\n                    simplifyPluralSuffix: this.options.simplifyPluralSuffix\n                });\n                s.interpolator = new Interpolator(this.options);\n                s.utils = { hasLoadedNamespace: this.hasLoadedNamespace.bind(this) };\n                s.backendConnector = new BackendConnector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);\n                s.backendConnector.on('*', (event, ...args) => {\n                    this.emit(event, ...args);\n                });\n                if (this.modules.languageDetector) {\n                    s.languageDetector = createClassOnDemand(this.modules.languageDetector);\n                    s.languageDetector.init(s, this.options.detection, this.options);\n                }\n                if (this.modules.i18nFormat) {\n                    s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);\n                    if (s.i18nFormat.init)\n                        s.i18nFormat.init(this);\n                }\n                this.translator = new Translator(this.services, this.options);\n                this.translator.on('*', (event, ...args) => {\n                    this.emit(event, ...args);\n                });\n                this.modules.external.forEach(m => {\n                    if (m.init)\n                        m.init(this);\n                });\n            }\n            if (!this.modules.languageDetector && !this.options.lng) {\n                this.logger.warn('init: no languageDetector is used and no lng is defined');\n            }\n            const storeApi = [\n                'getResource',\n                'hasResourceBundle',\n                'getResourceBundle',\n                'getDataByLanguage'\n            ];\n            storeApi.forEach(fcName => {\n                this[fcName] = (...args) => this.store[fcName](...args);\n            });\n            const storeApiChained = [\n                'addResource',\n                'addResources',\n                'addResourceBundle',\n                'removeResourceBundle'\n            ];\n            storeApiChained.forEach(fcName => {\n                this[fcName] = (...args) => {\n                    this.store[fcName](...args);\n                    return this;\n                };\n            });\n            const deferred = utils.defer();\n            const load = () => {\n                this.changeLanguage(this.options.lng, (err, t) => {\n                    this.isInitialized = true;\n                    this.logger.log('initialized', this.options);\n                    this.emit('initialized', this.options);\n                    deferred.resolve(t);\n                    callback(err, t);\n                });\n            };\n            if (this.options.resources || !this.options.initImmediate) {\n                load();\n            } else {\n                setTimeout(load, 0);\n            }\n            return deferred;\n        }\n        loadResources(language, callback = noop) {\n            let usedCallback = callback;\n            let usedLng = typeof language === 'string' ? language : this.language;\n            if (typeof language === 'function')\n                usedCallback = language;\n            if (!this.options.resources || this.options.partialBundledLanguages) {\n                if (usedLng && usedLng.toLowerCase() === 'cimode')\n                    return usedCallback();\n                const toLoad = [];\n                const append = lng => {\n                    if (!lng)\n                        return;\n                    const lngs = this.services.languageUtils.toResolveHierarchy(lng);\n                    lngs.forEach(l => {\n                        if (toLoad.indexOf(l) < 0)\n                            toLoad.push(l);\n                    });\n                };\n                if (!usedLng) {\n                    const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);\n                    fallbacks.forEach(l => append(l));\n                } else {\n                    append(usedLng);\n                }\n                if (this.options.preload) {\n                    this.options.preload.forEach(l => append(l));\n                }\n                this.services.backendConnector.load(toLoad, this.options.ns, usedCallback);\n            } else {\n                usedCallback(null);\n            }\n        }\n        reloadResources(lngs, ns, callback) {\n            const deferred = utils.defer();\n            if (!lngs)\n                lngs = this.languages;\n            if (!ns)\n                ns = this.options.ns;\n            if (!callback)\n                callback = noop;\n            this.services.backendConnector.reload(lngs, ns, err => {\n                deferred.resolve();\n                callback(err);\n            });\n            return deferred;\n        }\n        use(module) {\n            if (!module)\n                throw new Error('You are passing an undefined module! Please check the object you are passing to i18next.use()');\n            if (!module.type)\n                throw new Error('You are passing a wrong module! Please check the object you are passing to i18next.use()');\n            if (module.type === 'backend') {\n                this.modules.backend = module;\n            }\n            if (module.type === 'logger' || module.log && module.warn && module.error) {\n                this.modules.logger = module;\n            }\n            if (module.type === 'languageDetector') {\n                this.modules.languageDetector = module;\n            }\n            if (module.type === 'i18nFormat') {\n                this.modules.i18nFormat = module;\n            }\n            if (module.type === 'postProcessor') {\n                postProcessor.addPostProcessor(module);\n            }\n            if (module.type === '3rdParty') {\n                this.modules.external.push(module);\n            }\n            return this;\n        }\n        changeLanguage(lng, callback) {\n            this.isLanguageChangingTo = lng;\n            const deferred = utils.defer();\n            this.emit('languageChanging', lng);\n            const done = (err, l) => {\n                if (l) {\n                    this.language = l;\n                    this.languages = this.services.languageUtils.toResolveHierarchy(l);\n                    this.translator.changeLanguage(l);\n                    this.isLanguageChangingTo = undefined;\n                    this.emit('languageChanged', l);\n                    this.logger.log('languageChanged', l);\n                } else {\n                    this.isLanguageChangingTo = undefined;\n                }\n                deferred.resolve((...args) => this.t(...args));\n                if (callback)\n                    callback(err, (...args) => this.t(...args));\n            };\n            const setLng = lngs => {\n                const l = typeof lngs === 'string' ? lngs : this.services.languageUtils.getBestMatchFromCodes(lngs);\n                if (l) {\n                    if (!this.language) {\n                        this.language = l;\n                        this.languages = this.services.languageUtils.toResolveHierarchy(l);\n                    }\n                    if (!this.translator.language)\n                        this.translator.changeLanguage(l);\n                    if (this.services.languageDetector)\n                        this.services.languageDetector.cacheUserLanguage(l);\n                }\n                this.loadResources(l, err => {\n                    done(err, l);\n                });\n            };\n            if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {\n                setLng(this.services.languageDetector.detect());\n            } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {\n                this.services.languageDetector.detect(setLng);\n            } else {\n                setLng(lng);\n            }\n            return deferred;\n        }\n        getFixedT(lng, ns) {\n            const fixedT = (key, opts, ...rest) => {\n                let options;\n                if (typeof opts !== 'object') {\n                    options = this.options.overloadTranslationOptionHandler([\n                        key,\n                        opts\n                    ].concat(rest));\n                } else {\n                    options = { ...opts };\n                }\n                options.lng = options.lng || fixedT.lng;\n                options.lngs = options.lngs || fixedT.lngs;\n                options.ns = options.ns || fixedT.ns;\n                return this.t(key, options);\n            };\n            if (typeof lng === 'string') {\n                fixedT.lng = lng;\n            } else {\n                fixedT.lngs = lng;\n            }\n            fixedT.ns = ns;\n            return fixedT;\n        }\n        t(...args) {\n            return this.translator && this.translator.translate(...args);\n        }\n        exists(...args) {\n            return this.translator && this.translator.exists(...args);\n        }\n        setDefaultNamespace(ns) {\n            this.options.defaultNS = ns;\n        }\n        hasLoadedNamespace(ns, options = {}) {\n            if (!this.isInitialized) {\n                this.logger.warn('hasLoadedNamespace: i18next was not initialized', this.languages);\n                return false;\n            }\n            if (!this.languages || !this.languages.length) {\n                this.logger.warn('hasLoadedNamespace: i18n.languages were undefined or empty', this.languages);\n                return false;\n            }\n            const lng = this.languages[0];\n            const fallbackLng = this.options ? this.options.fallbackLng : false;\n            const lastLng = this.languages[this.languages.length - 1];\n            if (lng.toLowerCase() === 'cimode')\n                return true;\n            const loadNotPending = (l, n) => {\n                const loadState = this.services.backendConnector.state[`${ l }|${ n }`];\n                return loadState === -1 || loadState === 2;\n            };\n            if (options.precheck) {\n                const preResult = options.precheck(this, loadNotPending);\n                if (preResult !== undefined)\n                    return preResult;\n            }\n            if (this.hasResourceBundle(lng, ns))\n                return true;\n            if (!this.services.backendConnector.backend)\n                return true;\n            if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns)))\n                return true;\n            return false;\n        }\n        loadNamespaces(ns, callback) {\n            const deferred = utils.defer();\n            if (!this.options.ns) {\n                callback && callback();\n                return Promise.resolve();\n            }\n            if (typeof ns === 'string')\n                ns = [ns];\n            ns.forEach(n => {\n                if (this.options.ns.indexOf(n) < 0)\n                    this.options.ns.push(n);\n            });\n            this.loadResources(err => {\n                deferred.resolve();\n                if (callback)\n                    callback(err);\n            });\n            return deferred;\n        }\n        loadLanguages(lngs, callback) {\n            const deferred = utils.defer();\n            if (typeof lngs === 'string')\n                lngs = [lngs];\n            const preloaded = this.options.preload || [];\n            const newLngs = lngs.filter(lng => preloaded.indexOf(lng) < 0);\n            if (!newLngs.length) {\n                if (callback)\n                    callback();\n                return Promise.resolve();\n            }\n            this.options.preload = preloaded.concat(newLngs);\n            this.loadResources(err => {\n                deferred.resolve();\n                if (callback)\n                    callback(err);\n            });\n            return deferred;\n        }\n        dir(lng) {\n            if (!lng)\n                lng = this.languages && this.languages.length > 0 ? this.languages[0] : this.language;\n            if (!lng)\n                return 'rtl';\n            const rtlLngs = [\n                'ar',\n                'shu',\n                'sqr',\n                'ssh',\n                'xaa',\n                'yhd',\n                'yud',\n                'aao',\n                'abh',\n                'abv',\n                'acm',\n                'acq',\n                'acw',\n                'acx',\n                'acy',\n                'adf',\n                'ads',\n                'aeb',\n                'aec',\n                'afb',\n                'ajp',\n                'apc',\n                'apd',\n                'arb',\n                'arq',\n                'ars',\n                'ary',\n                'arz',\n                'auz',\n                'avl',\n                'ayh',\n                'ayl',\n                'ayn',\n                'ayp',\n                'bbz',\n                'pga',\n                'he',\n                'iw',\n                'ps',\n                'pbt',\n                'pbu',\n                'pst',\n                'prp',\n                'prd',\n                'ug',\n                'ur',\n                'ydd',\n                'yds',\n                'yih',\n                'ji',\n                'yi',\n                'hbo',\n                'men',\n                'xmn',\n                'fa',\n                'jpr',\n                'peo',\n                'pes',\n                'prs',\n                'dv',\n                'sam'\n            ];\n            return rtlLngs.indexOf(this.services.languageUtils.getLanguagePartFromCode(lng)) >= 0 ? 'rtl' : 'ltr';\n        }\n        createInstance(options = {}, callback) {\n            return new I18n(options, callback);\n        }\n        cloneInstance(options = {}, callback = noop) {\n            const mergedOptions = {\n                ...this.options,\n                ...options,\n                ...{ isClone: true }\n            };\n            const clone = new I18n(mergedOptions);\n            const membersToCopy = [\n                'store',\n                'services',\n                'language'\n            ];\n            membersToCopy.forEach(m => {\n                clone[m] = this[m];\n            });\n            clone.services = { ...this.services };\n            clone.services.utils = { hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone) };\n            clone.translator = new Translator(clone.services, clone.options);\n            clone.translator.on('*', (event, ...args) => {\n                clone.emit(event, ...args);\n            });\n            clone.init(mergedOptions, callback);\n            clone.translator.options = clone.options;\n            clone.translator.backendConnector.services.utils = { hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone) };\n            return clone;\n        }\n    }\n    return new I18n();\n});\ndefine('skylark-i18next/main',['./i18next'], function (i18next) {\n    'use strict';\n    return i18next;\n});\ndefine('skylark-i18next', ['skylark-i18next/main'], function (main) { return main; });\n\n"]}